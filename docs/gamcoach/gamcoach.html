<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.0" />
    <title>gamcoach.gamcoach API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>

<script>
    window.MathJax = {
        tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']]
        }
    };
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<script>
    /* Re-invoke MathJax when DOM content changes, for example during search. */
    document.addEventListener("DOMContentLoaded", () => {
        new MutationObserver(() => MathJax.typeset()).observe(
            document.querySelector("main.pdoc").parentNode,
            {childList: true}
        );
    })
</script>
<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>
                        <a class="pdoc-button module-list-button" href="../gamcoach.html">
<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-box-arrow-in-left" viewBox="0 0 16 16">
  <path fill-rule="evenodd" d="M10 3.5a.5.5 0 0 0-.5-.5h-8a.5.5 0 0 0-.5.5v9a.5.5 0 0 0 .5.5h8a.5.5 0 0 0 .5-.5v-2a.5.5 0 0 1 1 0v2A1.5 1.5 0 0 1 9.5 14h-8A1.5 1.5 0 0 1 0 12.5v-9A1.5 1.5 0 0 1 1.5 2h8A1.5 1.5 0 0 1 11 3.5v2a.5.5 0 0 1-1 0v-2z"/>
  <path fill-rule="evenodd" d="M4.146 8.354a.5.5 0 0 1 0-.708l3-3a.5.5 0 1 1 .708.708L5.707 7.5H14.5a.5.5 0 0 1 0 1H5.707l2.147 2.146a.5.5 0 0 1-.708.708l-3-3z"/>
</svg>                            &nbsp;gamcoach</a>


                        <input type="search" placeholder="Search..." role="searchbox" aria-label="search"
                               pattern=".+" required>



                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#GAMCoach">GAMCoach</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GAMCoach.__init__">GAMCoach</a>
                        </li>
                        <li>
                                <a class="variable" href="#GAMCoach.ebm">ebm</a>
                        </li>
                        <li>
                                <a class="variable" href="#GAMCoach.cont_mads">cont_mads</a>
                        </li>
                        <li>
                                <a class="variable" href="#GAMCoach.cat_distances">cat_distances</a>
                        </li>
                        <li>
                                <a class="variable" href="#GAMCoach.is_classifier">is_classifier</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.generate_cfs">generate_cfs</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.generate_cont_options">generate_cont_options</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.generate_cat_options">generate_cat_options</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.generate_inter_options">generate_inter_options</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.create_milp">create_milp</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.print_solution">print_solution</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.compute_mad">compute_mad</a>
                        </li>
                        <li>
                                <a class="function" href="#GAMCoach.compute_frequency_distance">compute_frequency_distance</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#search_sorted_lower_index">search_sorted_lower_index</a>
            </li>
            <li>
                    <a class="function" href="#sigmoid">sigmoid</a>
            </li>
            <li>
                    <a class="function" href="#get_model_data">get_model_data</a>
            </li>
    </ul>



                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
<a href="./../gamcoach.html">gamcoach</a><wbr>.gamcoach    </h1>

                        <div class="docstring"><p>Main module for GAM Coach.</p>

<p>GAM Coach implements a simple and flexible method to generate counterfactual
explanations for generalized additive models (GAMs).</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="sd">&quot;&quot;&quot;Main module for GAM Coach.</span>

<span class="sd">GAM Coach implements a simple and flexible method to generate counterfactual</span>
<span class="sd">explanations for generalized additive models (GAMs).</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">pulp</span>

<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">gaussian_kde</span>
<span class="kn">from</span> <span class="nn">interpret.glassbox</span> <span class="kn">import</span> <span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">.counterfactuals</span> <span class="kn">import</span> <span class="n">Counterfactuals</span>

<span class="n">SEED</span> <span class="o">=</span> <span class="mi">922</span>


<span class="k">class</span> <span class="nc">GAMCoach</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Main class for GAM Coach.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">],</span>
                 <span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">cont_mads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cat_distances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a GAMCoach object.</span>

<span class="sd">        Args:</span>
<span class="sd">            ebm (Union[ExplainableBoostingClassifier, ExplainableBoostingRegressor]):</span>
<span class="sd">                The trained EBM model. It can be either a classifier or a regressor.</span>
<span class="sd">            x_train (np.ndarray): The training data. It is used to compute the</span>
<span class="sd">                distance for different features.</span>
<span class="sd">            cont_mads (dict, optional): `feature_name` -&gt; `median absolute</span>
<span class="sd">                deviation score`. If it is provided, it is used to overwrite the</span>
<span class="sd">                computed MADs for continuous variables. It is useful when you</span>
<span class="sd">                want to provide a custom normalization function to compute the</span>
<span class="sd">                distance between continuous features.</span>
<span class="sd">            cat_distances (dict, optional): `feature_name` -&gt; {`level_name` -&gt; `distance`}.</span>
<span class="sd">                Level distance of categorical variables. By default, the distance</span>
<span class="sd">                is computed by (1 - frequency(level)) for each level. It imples</span>
<span class="sd">                that it is easier to move to a more frequent. If `cat_distances`</span>
<span class="sd">                is provided, it will overwrite the default distance for</span>
<span class="sd">                categorical variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span>
        <span class="sd">&quot;&quot;&quot;The trained EBM model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">x_train</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cont_mads</span>
        <span class="sd">&quot;&quot;&quot;Median absolute deviation (MAD) of continuous variables.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cat_distances</span>
        <span class="sd">&quot;&quot;&quot;Level distance of categorical variables. By default, the distance is</span>
<span class="sd">        computed by $(1 - \\frac{\\text{count of} L_i}{\\text{count of all L}})$</span>
<span class="sd">        for one level $L_i$. It implies that it is easier to move to a more</span>
<span class="sd">        frequent level.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If cont_mads is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cont_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cont_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">[</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># If cat_distance is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cat_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_frequency_distance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="c1"># Determine if the ebm is a classifier or a regressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;True if the ebm model is a classifier, false if it is a regressor.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">generate_cfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">cur_example</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">total_cfs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">target_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">sim_threshold_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
                     <span class="n">sim_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">categorical_weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                     <span class="n">features_to_vary</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_num_features_to_vary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">feature_ranges</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">continuous_integer_features</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counterfactuals</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate counterfactual examples.</span>

<span class="sd">        Use mixed-integer linear programming to generate optimal counterfactual</span>
<span class="sd">        examples for the given data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): The data point of interest. This function</span>
<span class="sd">                aims to find similar examples that the model gives different</span>
<span class="sd">                predictions.</span>
<span class="sd">            total_cfs (int, optional): The total number of counterfactuals to,</span>
<span class="sd">                generate. Default to 1.</span>
<span class="sd">            target_range (tuple, optional): The targetted prediction range. This</span>
<span class="sd">                parameter is required if the EBM is a regressor.</span>
<span class="sd">            sim_threshold_factor (float, optional): A positive float to automatically</span>
<span class="sd">                generate a similarity threshold. This parameter has no effect if</span>
<span class="sd">                `sim_threshold` is provided. If `sim_threshold` is</span>
<span class="sd">                not provided, we compute `sim_threshold` as `sim_threshold_factor`</span>
<span class="sd">                * average additive score range of all continuous features. If</span>
<span class="sd">                `sim_threshold_factor` is too small, it takes longer time to</span>
<span class="sd">                generate CFs. If `sim_threshold_factor` is too large, the</span>
<span class="sd">                algorithm might miss some optimal CFs.</span>
<span class="sd">            sim_threshold (float, optional): A positive float to determine how we</span>
<span class="sd">                decide if two bins of a continuous feature have similar scores.</span>
<span class="sd">                Two bins $b_1$ and $b_2$ are similar (the distant one will be</span>
<span class="sd">                removed) if $|b_1 - b_2| \\leq$ `sim_threshold`.</span>
<span class="sd">            categorical_weight (Union[float, str], optional): A positive float</span>
<span class="sd">                to scale the distances of options for categorical variables. Since</span>
<span class="sd">                we have very different distance functions for continuous and</span>
<span class="sd">                categorical features, we need to scale them so they are at a</span>
<span class="sd">                comparable range. To do that, we multiply the categorical feature&#39;s</span>
<span class="sd">                distances by `categorical_weight`. By default (&#39;auto&#39;), we scale</span>
<span class="sd">                the distances of categorical features so that they have the mean</span>
<span class="sd">                distance as continuous features.</span>
<span class="sd">            features_to_vary ([str], optional): A list of feature names that</span>
<span class="sd">                the CFs can change. If it is `None`, this function will use all</span>
<span class="sd">                features.</span>
<span class="sd">            max_num_features_to_vary (int, optional): The max number of features</span>
<span class="sd">                that the CF can vary. Default is no maximum.</span>
<span class="sd">            feature_ranges (dict, optional): A dictionary to control the permitted</span>
<span class="sd">                ranges/values for continuous/categorical features. It maps</span>
<span class="sd">                `feature_name` -&gt; [`min_value`, `max_value`] for continuous features,</span>
<span class="sd">                `feature_name` -&gt; [`level1`, `level2`, ...] for categorical features.</span>
<span class="sd">            continuous_integer_features (list, optional): A list of names of</span>
<span class="sd">                continuous features that need to be integers (e.g., age, FICO score)</span>
<span class="sd">            verbose (bool): True if you want it to print out the optimization</span>
<span class="sd">                process from each iteration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Counterfactuals: The generated counterfactual examples with their</span>
<span class="sd">                associated distances and change information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Transforming some parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_example</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur_example</span> <span class="o">=</span> <span class="n">cur_example</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">features_to_vary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features_to_vary</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;interaction&#39;</span>
            <span class="p">]</span>

        <span class="c1"># Step 1: Find the current score for each feature</span>
        <span class="c1"># This is done by ebm.explain_local()</span>
        <span class="n">cur_scores</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span>

        <span class="n">local_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">explain_local</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)</span><span class="o">.</span><span class="n">_internal_obj</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_data</span><span class="p">[</span><span class="s1">&#39;specific&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;scores&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Find the CF direction</span>

        <span class="c1"># Binary classification</span>
        <span class="c1"># Predicted 0 =&gt; +1</span>
        <span class="c1"># Predicted 1 =&gt; -1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cf_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">total_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cur_scores</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_scores</span><span class="p">])</span>
            <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="o">-</span><span class="n">total_score</span>
            <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regression</span>
            <span class="c1"># Increase +1</span>
            <span class="c1"># Decrease -1</span>
            <span class="k">if</span> <span class="n">target_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;target_range cannot be None when the model is a regressor&#39;</span><span class="p">)</span>

            <span class="n">predicted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">predicted_value</span> <span class="o">&gt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">predicted_value</span> <span class="o">&lt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The target_range cannot cover the current prediction&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">predicted_value</span> <span class="o">&lt;</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>

        <span class="c1"># Step 2: Generate continuous and categorical options</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Generate a similarity threshold if it is not provided</span>
        <span class="k">if</span> <span class="n">sim_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additive_ranges</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">cur_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">additive_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cur_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cur_values</span><span class="p">))</span>

            <span class="n">sim_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">additive_ranges</span><span class="p">)</span> <span class="o">*</span> <span class="n">sim_threshold_factor</span>

        <span class="c1"># To make it faster to solve the MILP problem, we can decrease the</span>
        <span class="c1"># number of variables by filtering out unhelpful and redundant options</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Unhelpful options: options that move the score to an undesirable</span>
        <span class="c1"># direction. For example, if we want to flip 0 to 1, options that decrease</span>
        <span class="c1"># the score are unhelpful.</span>
        <span class="c1">#</span>
        <span class="c1"># (2) Redundant options: for a set of options that give similar score</span>
        <span class="c1"># gains (bounded by a parameter epsilon), we only need to incldue one</span>
        <span class="c1"># option that has the lowest distance. This is only relevant for</span>
        <span class="c1"># continuous variables. Users can set the parameter epsilon. The default</span>
        <span class="c1"># should be relatively small, otherwise we might miss the optimal solution.</span>

        <span class="c1"># Step 2.1: Find all good options from continuous and categorical features</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># The parameter epsilon controls the threshold of how we determine</span>
                <span class="c1"># &quot;similar&quot; options for continuous variables</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">sim_threshold</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>

                <span class="c1"># Users can require the continuous feature to have integer values</span>
                <span class="c1"># For example, age, FICO score, and number of accounts</span>
                <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">continuous_integer_features</span> <span class="ow">and</span> <span class="n">cur_feature_name</span> <span class="ow">in</span> <span class="n">continuous_integer_features</span><span class="p">:</span>
                    <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">cur_cont_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cont_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_name</span><span class="p">,</span>
                    <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">,</span>
                    <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">score_gain_bound</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">need_to_be_int</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cont_options</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>
                <span class="n">cur_cat_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">cur_cat_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cat_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">score_gain_bound</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cat_options</span>

        <span class="c1"># Step 2.2: Filter out undesired options (based on the feature_range)</span>
        <span class="k">if</span> <span class="n">feature_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">feature_ranges</span><span class="p">:</span>
                <span class="n">cur_range</span> <span class="o">=</span> <span class="n">feature_ranges</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="c1"># Delete options that use ineligible options</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">cur_target</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">cur_target</span> <span class="o">&lt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">cur_target</span> <span class="o">&gt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur_range</span><span class="p">:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c1"># Step 2.3: Compute the interaction offsets for all possible options</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">cur_feature_index_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cur_feature_index_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_inter_options</span><span class="p">(</span>
                    <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span> <span class="n">cur_feature_index_2</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span>
                <span class="p">)</span>

        <span class="c1"># Step 2.4: Rescale categorical distances so that they have the same mean</span>
        <span class="c1"># as continuous variables (default)</span>
        <span class="k">if</span> <span class="n">categorical_weight</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">cont_distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cat_distances</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cont_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cat_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">categorical_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cont_distances</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cat_distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
            <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">categorical_weight</span>

        <span class="c1"># Step 3. Formulate the MILP model and solve it</span>

        <span class="c1"># Find diverse solutions by accumulatively muting the optimal solutions</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">muted_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_cfs</span><span class="p">)):</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_milp</span><span class="p">(</span>
                <span class="n">cf_direction</span><span class="p">,</span>
                <span class="n">needed_score_gain</span><span class="p">,</span>
                <span class="n">features_to_vary</span><span class="p">,</span>
                <span class="n">options</span><span class="p">,</span>
                <span class="n">max_num_features_to_vary</span><span class="p">,</span>
                <span class="n">muted_variables</span><span class="o">=</span><span class="n">muted_variables</span>
            <span class="p">)</span>

            <span class="n">model</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">apis</span><span class="o">.</span><span class="n">PULP_CBC_CMD</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">warmStart</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;solver runs for </span><span class="si">{:.2f}</span><span class="s1"> seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">solutionTime</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;status: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">LpStatus</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">]))</span>

            <span class="n">active_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Print the optimal solution</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">varValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">active_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Found solutions:&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_solution</span><span class="p">(</span><span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

            <span class="c1"># Collect the current solution and mute the associated variables</span>
            <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">active_variables</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">objective</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">muted_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">cfs</span> <span class="o">=</span> <span class="n">Counterfactuals</span><span class="p">(</span><span class="n">solutions</span><span class="p">,</span> <span class="n">is_successful</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cfs</span>

    <span class="k">def</span> <span class="nf">generate_cont_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                            <span class="n">cur_feature_name</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                            <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cont_mads</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                            <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                            <span class="n">need_to_be_int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this continuous variable. This function</span>
<span class="sd">        would filter out all options that are:</span>

<span class="sd">        1. Not helpful for the counterfactual generation.</span>
<span class="sd">        2. Give similar score gain but requires larger distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_name (str): Name of the current feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cont_mads (dict): A map of feature_name =&gt; MAD score.</span>
<span class="sd">            cur_example (list): Current sample values</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            epsilon (float): The threshold to determine if two options give similar</span>
<span class="sd">                score gains. Score gains $s_1$ and $s_2$ are similar if</span>
<span class="sd">                $|s_1 - s_2| &lt;$ epsilon. Smaller epsilon significantly increases</span>
<span class="sd">                the time to solve the MILP. Large epsilon might filter out the</span>
<span class="sd">                optimal CF. Defaults to 0.005.</span>
<span class="sd">            need_to_be_int (bool): True if the target values for this continuous</span>
<span class="sd">                variable need to have integer values.</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For each continuous feature, each bin is a variable</span>
        <span class="c1"># For each bin, we need to compute (1) score gain, (2) distance</span>
        <span class="c1"># (1) score gain is the difference between new bin and current bin</span>
        <span class="c1"># (2) distance is L1 distance divided by median absolute deviation (MAD)</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance,</span>
        <span class="c1"># bin_index)</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify which bin this value falls into</span>
        <span class="n">cur_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">additives</span><span class="p">[</span><span class="n">cur_bin_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_score</span><span class="p">)</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                        <span class="n">bin_starts_feature</span><span class="p">,</span> <span class="n">cur_feature_value</span>
                    <span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="c1"># Because of the special binning structure of EBM, the distance of</span>
            <span class="c1"># bins on the left to the current value is different from the bins</span>
            <span class="c1"># that are on the right</span>
            <span class="c1">#</span>
            <span class="c1"># For bins on the left, the raw distance is abs(bin_start[i + 1] - x)</span>
            <span class="c1"># For bins on the right, the raw distance is abs(bin_start[i] - x)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">cur_feature_value</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it is need to be an integer</span>
                <span class="c1"># If so, it would be the closest integer to the right point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="c1"># Subtract a very smaller value to make the target</span>
                    <span class="c1"># technically fall into the left bin</span>
                    <span class="n">target</span> <span class="o">-=</span> <span class="mf">1e-4</span>

            <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it should be an integer value</span>
                <span class="c1"># If so, it would be the closest integer to the left point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

            <span class="c1"># Scale the distance based on the deviation of the feature (how changable it is)</span>
            <span class="k">if</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">/=</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

            <span class="c1"># Compute score gain which has two parts:</span>
            <span class="c1"># (1) gain from the change of main effect</span>
            <span class="c1"># (2) gain from the change of interaction effect</span>

            <span class="c1"># Main effect</span>
            <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

            <span class="c1"># Interaction terms</span>
            <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">],</span> <span class="n">target</span>
                <span class="p">)</span>
                <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

            <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

            <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Filter out of bound options</span>
            <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="n">cont_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="c1"># Now we can apply the second round of filtering to remove redundant options</span>
        <span class="c1"># Redundant options refer to bins that give similar score gain with larger distance</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cont_options</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cont_options</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cont_options</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">cont_options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cont_options</span>

    <span class="k">def</span> <span class="nf">generate_cat_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                             <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span>
                             <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                             <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this categorical variable. This function</span>
<span class="sd">        would filter out all options that are not helpful for the counterfactual</span>
<span class="sd">        generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cur_cat_distance (dict): A map of feature_level =&gt; 1 - frequency.</span>
<span class="sd">            cur_example (list): Current sample values.</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score_gain, distance, bin_index).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find other options for this categorical variable</span>
        <span class="c1"># For each option, we compute the (1) score gain, and (2) distance</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Score gain is the same as continuous variables</span>
        <span class="c1"># (2) The distance is determined by 1 - the level frequency in the</span>
        <span class="c1"># training data. It implies that levels with high frequency are easier</span>
        <span class="c1"># to &quot;move to&quot;</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance, bin_index)</span>
        <span class="n">cat_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>
                    <span class="n">other_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">bin_starts_feature</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feeature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur_feature_value</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">cur_cat_distance</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="c1"># Compute score gain which has two parts:</span>
                <span class="c1"># (1) gain from the change of main effect</span>
                <span class="c1"># (2) gain from the change of interaction effect</span>

                <span class="c1"># Main effect</span>
                <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># Interaction terms</span>
                <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                    <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

                <span class="c1"># Skip unhelpful options</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Filter out of bound options</span>
                <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="n">cat_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cat_options</span>


    <span class="k">def</span> <span class="nf">generate_inter_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span>
                               <span class="n">cur_feature_index_2</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all possible options for this interaction variable.</span>

<span class="sd">        Interaction terms are interesting in this MILP. Each option counts as a</span>
<span class="sd">        variable, but each variable only affects the score gain, not the distance.</span>

<span class="sd">        Note that in EBM, the bin definitions for interaction terms can be different</span>
<span class="sd">        from their defintiions for individual continuous variables.</span>

<span class="sd">        To model interaction terms, we can think it as a binary variable. The</span>
<span class="sd">        value is determined by the multiplication of two main effect variables.</span>
<span class="sd">        Each interaction variable describes a combination of two main effect</span>
<span class="sd">        variables. Therefore, say continuous variable A has $x$ probable options,</span>
<span class="sd">        and another continuous variable B has $y$ probable options, then we should</span>
<span class="sd">        add $x \\times y$ binary variables to offset their probable interaction</span>
<span class="sd">        effects.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_feature_id (int): The id of this interaction effect.</span>
<span class="sd">            cur_feature_index_1 (int): The index of the first main effect.</span>
<span class="sd">            cur_feature_index_2 (int): The index of the second main effect.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            options (dict): The current option list, feature_name -&gt;</span>
<span class="sd">                [`target`, `score_gain`, `distance`, `bin_id`].</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of option tuples (target, score_gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the sub-types for this interaction term</span>
        <span class="n">cur_feature_type_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_type_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># Get the sub-names for this interaction term</span>
        <span class="n">cur_feature_name_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_name_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># The first column and row are reserved for missing values (even with</span>
        <span class="c1"># categorical features)</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Four possibilities here: cont x cont, cont x cat, cat x cont, cat x cat.</span>
        <span class="c1"># Each has a different way to lookup the bin table.</span>
        <span class="n">inter_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through all possible combinations of options from these two</span>
        <span class="c1"># variables</span>
        <span class="k">for</span> <span class="n">opt_1</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">opt_2</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_2</span><span class="p">]:</span>

                <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_1</span><span class="p">)</span>
                <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_2</span><span class="p">)</span>

                <span class="n">bin_1</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">bin_2</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">cur_feature_type_1</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cont x cont</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cont x cat</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cat x cont</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cat x cat</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">new_score</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">bin_1</span><span class="p">,</span> <span class="n">bin_2</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">new_score</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># The score gain on the interaction term need to offset the interaction</span>
                <span class="c1"># score gain we have already counted on the main effect options. That</span>
                <span class="c1"># score is saved in the option tuple.</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

                <span class="c1"># Optimization: here we cannot comapre the score_gain with</span>
                <span class="c1"># original interaction score to filter interaction options,</span>
                <span class="c1"># because the choice of two individual main effects do not</span>
                <span class="c1"># consier this interaction score</span>
                <span class="c1">#</span>
                <span class="c1"># Basically, the score gain of one interaction effect does</span>
                <span class="c1"># not affect the way we choose options for the main</span>
                <span class="c1"># variables. Only the solver can decide that :(</span>

                <span class="n">inter_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">score_gain</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
                    <span class="mi">0</span>
                <span class="p">])</span>

        <span class="k">return</span> <span class="n">inter_options</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_milp</span><span class="p">(</span><span class="n">cf_direction</span><span class="p">,</span> <span class="n">needed_score_gain</span><span class="p">,</span> <span class="n">features_to_vary</span><span class="p">,</span>
                    <span class="n">options</span><span class="p">,</span> <span class="n">max_num_features_to_vary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">muted_variables</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MILP to find counterfactuals (CF) using PuLP.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer +1 if 0 =&gt; 1, -1 if 1 =&gt; 0 (classification),</span>
<span class="sd">                +1 if we need to incrase the prediction, -1 if decrease (regression).</span>
<span class="sd">            needed_score_gain (float): The score gain needed to achieve the CF goal.</span>
<span class="sd">            features_to_vary (list[str]): Feature names of features that the</span>
<span class="sd">                generated CF can change.</span>
<span class="sd">            options (dict): Possible options for each variable. Each option is a</span>
<span class="sd">                list [target, score_gain, distance, bin_index].</span>
<span class="sd">            max_num_features_to_vary (int, optional): Max number of features that the</span>
<span class="sd">                generated CF can change. If the value is `None`, the CFs can</span>
<span class="sd">                change any number of features.</span>
<span class="sd">            muted_variables (list[str], optional): Variables that this MILP should</span>
<span class="sd">                not use. This is useful to mute optimal variables so we can explore</span>
<span class="sd">                diverse solutions. This list should not include interaction variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (`model`, `variables`), where `model` is a pulp.LpProblem</span>
<span class="sd">            model that encodes the MILP problem, and `variables` is a dict of</span>
<span class="sd">            variables used in the `model`: `feature_name` =&gt; [`variables`].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a model (minimizing the distance)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpProblem</span><span class="p">(</span><span class="s1">&#39;ebmCounterfactual&#39;</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpMinimize</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">score_gain</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">muted_variables_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">muted_variables</span><span class="p">)</span>

        <span class="c1"># Create variables</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>
            <span class="c1"># Each variable encodes an option (0: not use this option,</span>
            <span class="c1"># 1: use this option)</span>
            <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

                <span class="c1"># Skip the muted variables</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span>
                                    <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Binary&#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">score_gain</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>

                <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

            <span class="c1"># A local constraint is that we can only at most selection one option from</span>
            <span class="c1"># one feature</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">cur_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>

        <span class="c1"># Users can also set `max_num_features_to_vary` to control the total</span>
        <span class="c1"># number of features to vary</span>
        <span class="k">if</span> <span class="n">max_num_features_to_vary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">main_variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">main_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_num_features_to_vary</span>

        <span class="c1"># Create variables for interaction effects</span>
        <span class="k">for</span> <span class="n">opt_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">in</span> <span class="n">opt_name</span><span class="p">:</span>
                <span class="n">f1_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+)\sx\s.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>
                <span class="n">f2_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+\sx\s(.+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">f1_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span> <span class="ow">and</span> <span class="n">f2_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>

                    <span class="c1"># We need to include this interaction effect</span>
                    <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opt_name</span><span class="p">,</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
                                            <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Continuous&#39;</span><span class="p">)</span>
                        <span class="n">z</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># Need to iterate through existing variables for f1 and f2 to find</span>
                        <span class="c1"># the corresponding variables</span>
                        <span class="n">x_f1</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">x_f2</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="c1"># Skp if this interaction variable involves muted main variable</span>
                        <span class="n">x_f1_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">x_f2_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f2_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">x_f1_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span> <span class="ow">or</span> <span class="n">x_f2_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f1_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f1_name</span><span class="p">:</span>
                                <span class="n">x_f1</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f2_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f2_name</span><span class="p">:</span>
                                <span class="n">x_f2</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">assert</span><span class="p">(</span><span class="n">x_f1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x_f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

                        <span class="c1"># variable z is actually the product of x_f1 and x_f2</span>
                        <span class="c1"># We can linearize it by 3 constraints</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f1</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f2</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">x_f1</span> <span class="o">+</span> <span class="n">x_f2</span> <span class="o">-</span> <span class="mi">1</span>

                        <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                    <span class="n">variables</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

        <span class="c1"># Use constraint to express counterfactual</span>
        <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&gt;=</span> <span class="n">needed_score_gain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="n">needed_score_gain</span>

        <span class="c1"># We want to minimize the distance</span>
        <span class="n">model</span> <span class="o">+=</span> <span class="n">distance</span>

        <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">print_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the optimal solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): the original data point.</span>
<span class="sd">            active_variables (list[variable]): binary variables with value 1.</span>
<span class="sd">            options (dict): all the possible options for all features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
            <span class="c1"># Skip interaction vars (included)</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">bin_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="c1"># Find the original value</span>
                <span class="n">org_value</span> <span class="o">=</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span>

                <span class="c1"># Find the target bin</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">f_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">):</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; inf)&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">org_value</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">org_value</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_i</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Change &lt;</span><span class="si">{}</span><span class="s1">&gt; from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span><span class="p">,</span> <span class="n">org_value</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_bin</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="p">))</span>
                        <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">f_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_x_&#39;</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="p">)</span>
                <span class="n">bin_0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+),\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">bin_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:\d+,(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_0</span> <span class="ow">and</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trigger interaction term: &lt;</span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span>
                        <span class="p">))</span>
                        <span class="k">break</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_mad</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the median absolute deviation of a continuous feature.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of continuous values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: MAD value of xs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">xs_median</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mad</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_frequency_distance</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For categorical variables, we compute 1 - frequency as their distance. It implies</span>
<span class="sd">        that switching to a frequent value takes less effort.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of categorical values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: category level -&gt; 1 - frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span>


<span class="k">def</span> <span class="nf">search_sorted_lower_index</span><span class="p">(</span><span class="n">sorted_edges</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary search to locate the correct bin for continuous features.&quot;&quot;&quot;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="c1"># Handle out of bound issues</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">right</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">left</span>

    <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span>


<span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sigmoid function.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_resort_categorical_level</span><span class="p">(</span><span class="n">col_mapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resort the levels in the categorical encoders if all levels can be converted</span>
<span class="sd">    to numbers (integer or float).</span>

<span class="sd">    Args:</span>
<span class="sd">        col_mapping: the dictionary that maps level string to int</span>

<span class="sd">    Returns:</span>
<span class="sd">        New col_mapping if all levels can be converted to numbers, otherwise</span>
<span class="sd">        the original col_mapping</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">is_number</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">float</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">is_number</span><span class="p">,</span> <span class="n">col_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>

        <span class="n">key_tuples</span> <span class="o">=</span> <span class="p">[(</span><span class="n">k</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">col_mapping</span><span class="o">.</span><span class="n">keys</span><span class="p">()]</span>
        <span class="n">sorted_key_tuples</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">key_tuples</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">new_mapping</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">sorted_key_tuples</span><span class="p">:</span>
            <span class="n">new_mapping</span><span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="n">value</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">new_mapping</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">col_mapping</span>


<span class="k">def</span> <span class="nf">_init_feature_descriptions</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="n">label_encoder</span><span class="p">):</span>
    <span class="c1"># Initialize the feature description dictionary</span>
    <span class="n">feature_descriptions</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
        <span class="n">cur_name</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_type</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Use the feature name as the default display name</span>
        <span class="k">if</span> <span class="n">cur_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">cur_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;displayName&#39;</span><span class="p">:</span> <span class="n">cur_name</span><span class="p">,</span>
                <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span>
            <span class="p">}</span>

        <span class="c1"># For categorical features, we can also give display name and description</span>
        <span class="c1"># for different levels</span>
        <span class="k">elif</span> <span class="n">cur_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>

            <span class="n">level_descriptions</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">label_encoder</span><span class="p">[</span><span class="n">cur_name</span><span class="p">]:</span>
                <span class="n">level_descriptions</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;displayName&#39;</span><span class="p">:</span> <span class="n">label_encoder</span><span class="p">[</span><span class="n">cur_name</span><span class="p">][</span><span class="n">level</span><span class="p">],</span>
                    <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="p">}</span>

            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">cur_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;displayName&#39;</span><span class="p">:</span> <span class="n">cur_name</span><span class="p">,</span>
                <span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                <span class="s1">&#39;levelDescription&#39;</span><span class="p">:</span> <span class="n">level_descriptions</span>
            <span class="p">}</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">feature_descriptions</span>


<span class="k">def</span> <span class="nf">_init_feature_configuration</span><span class="p">(</span><span class="n">ebm</span><span class="p">):</span>
    <span class="c1"># Initialize the feature configuration dictionary</span>
    <span class="n">feature_configuration</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
        <span class="n">cur_name</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_type</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Use the feature name as the default display name</span>
        <span class="k">if</span> <span class="n">cur_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span> <span class="ow">or</span> <span class="n">cur_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
            <span class="n">feature_configuration</span><span class="p">[</span><span class="n">cur_name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;difficulty&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;requiresInt&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;requiresIncreasing&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;requiresDecreasing&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;usesTransform&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                <span class="s1">&#39;acceptableRange&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">return</span> <span class="n">feature_configuration</span>


<span class="k">def</span> <span class="nf">_get_kde_sample</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">n_sample</span><span class="o">=</span><span class="mi">200</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute kernel density estimation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">gaussian_kde</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>

    <span class="n">sample_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">n_sample</span><span class="p">)</span>
    <span class="n">sample_y</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">(</span><span class="n">sample_x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sample_x</span><span class="p">,</span> <span class="n">sample_y</span>


<span class="k">def</span> <span class="nf">get_model_data</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">model_info</span><span class="p">,</span> <span class="n">resort_categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">feature_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_level_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">feature_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the model data for GAM Coach.</span>
<span class="sd">    Args:</span>
<span class="sd">        ebm: Trained EBM model. ExplainableBoostingClassifier or</span>
<span class="sd">            ExplainableBoostingRegressor object.</span>
<span class="sd">        x_train: Training data. We use it to compute the mean absolute deviation</span>
<span class="sd">            score for continuous features, and frequency scores for categorical</span>
<span class="sd">            features.</span>
<span class="sd">        model_info: Information about the model (class names, regression target</span>
<span class="sd">            name). For classification, the order of classes matters. It should</span>
<span class="sd">            be consistent with the class encoding index. For example, the first</span>
<span class="sd">            element should be the name for class 0.</span>
<span class="sd">            It has format:</span>
<span class="sd">            `{&#39;classes&#39;: [&#39;loan rejection&#39;, &#39;loan approval&#39;]}` or</span>
<span class="sd">            `{&#39;regressionName&#39;: &#39;interest rate&#39;}`</span>
<span class="sd">        resort_categorical: Whether to sort the levels in categorical variable</span>
<span class="sd">            by increasing order if all levels can be converted to numbers.</span>
<span class="sd">        feature_info: You can provide a dictionary to give a separate display</span>
<span class="sd">            name and optional description for each feature. By default, the</span>
<span class="sd">            display name is the same as the feature name, and the description</span>
<span class="sd">            is an emtpy string. `feature_info` can be partial (only including</span>
<span class="sd">            some features). It has format:</span>
<span class="sd">            `{&#39;feature_name&#39;: [&#39;display_name&#39;, &#39;description&#39;]}`</span>
<span class="sd">        feature_level_info: You can provide a dictionary to give separate display</span>
<span class="sd">            name and optional description for each level of categorical features.</span>
<span class="sd">            By default, the display name is the same as the level name, and the</span>
<span class="sd">            description is an empty string. `feature_info` can be partial</span>
<span class="sd">            (e.g., only including some levels from some categorical features).</span>
<span class="sd">            It has format:</span>
<span class="sd">            `{&#39;feature_name&#39;: {level_id: [&#39;display_name&#39;, &#39;description&#39;]}}`</span>
<span class="sd">        feature_config: You can provide a dictionary to configure the difficulty,</span>
<span class="sd">            integer requirement, and acceptable range of individual features.</span>
<span class="sd">            The difficulty is an integer between 1 and 6: 1 (very easy to change),</span>
<span class="sd">            2 (easy), 3 (default), 4 (hard), 5 (very hard), 6 (impossible to change).</span>
<span class="sd">            By default, difficulty is set to 3 for all features, requiresInt is</span>
<span class="sd">            False for continuous variables, and acceptanceRange is None (search</span>
<span class="sd">            all range).</span>
<span class="sd">            The dictionary property has the following format:</span>
<span class="sd">            `{&#39;difficulty&#39;: 3, &#39;requiresInt&#39;: True, &#39;acceptableRange&#39;: None}`</span>
<span class="sd">    Returns:</span>
<span class="sd">        A Python dictionary of model data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ROUND</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="c1"># Main model info on each feature</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Track the encoding of categorical feature levels</span>
    <span class="n">labelEncoder</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Track the score range</span>
    <span class="n">score_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))):</span>
        <span class="n">cur_feature</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;importance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_importances_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Handle interaction term differently from cont/cat</span>
        <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)</span>

            <span class="c1"># Info for each individual feature</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># Skip the first item from both dimensions</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span>
                                            <span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Get the bin label info</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Encode categorical levels as integers</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span>
                    <span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span>
                    <span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]))</span>

            <span class="c1"># Get density info</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]))</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]))</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Skip the first item (reserved for missing value)</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">col_bin_counts_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># Track the global score range</span>
            <span class="n">score_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">score_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">score_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">score_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="c1"># Add the binning information for continuous features</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># Add the bin information</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)</span>

                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">])</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="c1"># Get the level value mapping</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">resort_categorical</span><span class="p">:</span>
                    <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">_resort_categorical_level</span><span class="p">(</span>
                        <span class="n">level_str_to_int</span><span class="p">)</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                               <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)))</span>

                <span class="c1"># Add the hist information</span>
                <span class="c1"># For categorical data, the edges are strings</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                               <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)))</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">resort_categorical</span><span class="p">:</span>
                    <span class="n">cur_bin_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
                    <span class="p">))</span>
                    <span class="n">cur_bin_info</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cur_bin_info</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>

                    <span class="n">cur_hist_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">],</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]))</span>
                    <span class="n">cur_hist_info</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cur_hist_info</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_hist_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_hist_info</span><span class="p">]</span>

                <span class="c1"># Add the label encoding information</span>
                <span class="n">labelEncoder</span><span class="p">[</span><span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">level_str_to_int</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_feature</span><span class="p">)</span>

    <span class="n">score_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ROUND</span><span class="p">),</span> <span class="n">score_range</span><span class="p">))</span>

    <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">feature_types</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Sample data does not record interaction features</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;interaction&#39;</span><span class="p">):</span>
            <span class="n">feature_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">feature_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Compute the MAD scores and frequencies</span>
    <span class="n">ebm_cont_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">contMads</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cont_indexes</span><span class="p">:</span>
        <span class="n">contMads</span><span class="p">[</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">GAMCoach</span><span class="o">.</span><span class="n">compute_mad</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

    <span class="n">ebm_cat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">catDistances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cat_indexes</span><span class="p">:</span>
        <span class="n">catDistances</span><span class="p">[</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">GAMCoach</span><span class="o">.</span><span class="n">compute_frequency_distance</span><span class="p">(</span>
            <span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Initialize a feature description dictionary (provide more information about</span>
    <span class="c1"># each feature in the UI)</span>
    <span class="n">feature_descriptions</span> <span class="o">=</span> <span class="n">_init_feature_descriptions</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="n">labelEncoder</span><span class="p">)</span>

    <span class="c1"># Overwrite some entries in the default feature_descriptions</span>
    <span class="k">if</span> <span class="n">feature_info</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_info</span><span class="p">:</span>
            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;displayName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">feature_level_info</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_level_info</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">]:</span>
                <span class="n">display_name</span> <span class="o">=</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">level</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;levelDescription&#39;</span><span class="p">][</span>
                    <span class="n">level</span><span class="p">][</span><span class="s1">&#39;displayName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">display_name</span>
                <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;levelDescription&#39;</span><span class="p">][</span>
                    <span class="n">level</span><span class="p">][</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">description</span>

    <span class="c1"># Put descriptions under the &#39;features&#39; key</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">feature_descriptions</span><span class="p">):</span>
            <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>

    <span class="c1"># Set the feature configurations</span>
    <span class="n">feature_configurations</span> <span class="o">=</span> <span class="n">_init_feature_configuration</span><span class="p">(</span><span class="n">ebm</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">feature_config</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_config</span><span class="p">:</span>
            <span class="n">cur_config</span> <span class="o">=</span> <span class="n">feature_config</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;requiresInt&#39;</span><span class="p">,</span> <span class="s1">&#39;difficulty&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptableRange&#39;</span><span class="p">,</span>
                <span class="s1">&#39;requiresIncreasing&#39;</span><span class="p">,</span> <span class="s1">&#39;requiresDecreasing&#39;</span><span class="p">,</span> <span class="s1">&#39;usesTransform&#39;</span>
            <span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">cur_config</span><span class="p">):</span>
                    <span class="n">feature_configurations</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_config</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="c1"># Attach the configuration to the feature field</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">feature_configurations</span><span class="p">):</span>
            <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_configurations</span><span class="p">[</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;intercept&#39;</span><span class="p">:</span> <span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="s1">&#39;classes_&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">,</span>
        <span class="s1">&#39;isClassifier&#39;</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="s1">&#39;classes_&#39;</span><span class="p">),</span>
        <span class="s1">&#39;modelInfo&#39;</span><span class="p">:</span> <span class="n">model_info</span><span class="p">,</span>
        <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="n">features</span><span class="p">,</span>
        <span class="s1">&#39;labelEncoder&#39;</span><span class="p">:</span> <span class="n">labelEncoder</span><span class="p">,</span>
        <span class="s1">&#39;scoreRange&#39;</span><span class="p">:</span> <span class="n">score_range</span><span class="p">,</span>
        <span class="s1">&#39;featureNames&#39;</span><span class="p">:</span> <span class="n">feature_names</span><span class="p">,</span>
        <span class="s1">&#39;featureTypes&#39;</span><span class="p">:</span> <span class="n">feature_types</span><span class="p">,</span>
        <span class="s1">&#39;contMads&#39;</span><span class="p">:</span> <span class="n">contMads</span><span class="p">,</span>
        <span class="s1">&#39;catDistances&#39;</span><span class="p">:</span> <span class="n">catDistances</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">data</span>
</pre></div>

        </details>

            </section>
                <section id="GAMCoach">
                                <div class="attr class">
        <a class="headerlink" href="#GAMCoach">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GAMCoach</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GAMCoach</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Main class for GAM Coach.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">],</span>
                 <span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">cont_mads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cat_distances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a GAMCoach object.</span>

<span class="sd">        Args:</span>
<span class="sd">            ebm (Union[ExplainableBoostingClassifier, ExplainableBoostingRegressor]):</span>
<span class="sd">                The trained EBM model. It can be either a classifier or a regressor.</span>
<span class="sd">            x_train (np.ndarray): The training data. It is used to compute the</span>
<span class="sd">                distance for different features.</span>
<span class="sd">            cont_mads (dict, optional): `feature_name` -&gt; `median absolute</span>
<span class="sd">                deviation score`. If it is provided, it is used to overwrite the</span>
<span class="sd">                computed MADs for continuous variables. It is useful when you</span>
<span class="sd">                want to provide a custom normalization function to compute the</span>
<span class="sd">                distance between continuous features.</span>
<span class="sd">            cat_distances (dict, optional): `feature_name` -&gt; {`level_name` -&gt; `distance`}.</span>
<span class="sd">                Level distance of categorical variables. By default, the distance</span>
<span class="sd">                is computed by (1 - frequency(level)) for each level. It imples</span>
<span class="sd">                that it is easier to move to a more frequent. If `cat_distances`</span>
<span class="sd">                is provided, it will overwrite the default distance for</span>
<span class="sd">                categorical variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span>
        <span class="sd">&quot;&quot;&quot;The trained EBM model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">x_train</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cont_mads</span>
        <span class="sd">&quot;&quot;&quot;Median absolute deviation (MAD) of continuous variables.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cat_distances</span>
        <span class="sd">&quot;&quot;&quot;Level distance of categorical variables. By default, the distance is</span>
<span class="sd">        computed by $(1 - \\frac{\\text{count of} L_i}{\\text{count of all L}})$</span>
<span class="sd">        for one level $L_i$. It implies that it is easier to move to a more</span>
<span class="sd">        frequent level.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If cont_mads is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cont_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cont_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">[</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># If cat_distance is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cat_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_frequency_distance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="c1"># Determine if the ebm is a classifier or a regressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;True if the ebm model is a classifier, false if it is a regressor.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">generate_cfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">cur_example</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">total_cfs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">target_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">sim_threshold_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
                     <span class="n">sim_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">categorical_weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                     <span class="n">features_to_vary</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_num_features_to_vary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">feature_ranges</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">continuous_integer_features</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counterfactuals</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate counterfactual examples.</span>

<span class="sd">        Use mixed-integer linear programming to generate optimal counterfactual</span>
<span class="sd">        examples for the given data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): The data point of interest. This function</span>
<span class="sd">                aims to find similar examples that the model gives different</span>
<span class="sd">                predictions.</span>
<span class="sd">            total_cfs (int, optional): The total number of counterfactuals to,</span>
<span class="sd">                generate. Default to 1.</span>
<span class="sd">            target_range (tuple, optional): The targetted prediction range. This</span>
<span class="sd">                parameter is required if the EBM is a regressor.</span>
<span class="sd">            sim_threshold_factor (float, optional): A positive float to automatically</span>
<span class="sd">                generate a similarity threshold. This parameter has no effect if</span>
<span class="sd">                `sim_threshold` is provided. If `sim_threshold` is</span>
<span class="sd">                not provided, we compute `sim_threshold` as `sim_threshold_factor`</span>
<span class="sd">                * average additive score range of all continuous features. If</span>
<span class="sd">                `sim_threshold_factor` is too small, it takes longer time to</span>
<span class="sd">                generate CFs. If `sim_threshold_factor` is too large, the</span>
<span class="sd">                algorithm might miss some optimal CFs.</span>
<span class="sd">            sim_threshold (float, optional): A positive float to determine how we</span>
<span class="sd">                decide if two bins of a continuous feature have similar scores.</span>
<span class="sd">                Two bins $b_1$ and $b_2$ are similar (the distant one will be</span>
<span class="sd">                removed) if $|b_1 - b_2| \\leq$ `sim_threshold`.</span>
<span class="sd">            categorical_weight (Union[float, str], optional): A positive float</span>
<span class="sd">                to scale the distances of options for categorical variables. Since</span>
<span class="sd">                we have very different distance functions for continuous and</span>
<span class="sd">                categorical features, we need to scale them so they are at a</span>
<span class="sd">                comparable range. To do that, we multiply the categorical feature&#39;s</span>
<span class="sd">                distances by `categorical_weight`. By default (&#39;auto&#39;), we scale</span>
<span class="sd">                the distances of categorical features so that they have the mean</span>
<span class="sd">                distance as continuous features.</span>
<span class="sd">            features_to_vary ([str], optional): A list of feature names that</span>
<span class="sd">                the CFs can change. If it is `None`, this function will use all</span>
<span class="sd">                features.</span>
<span class="sd">            max_num_features_to_vary (int, optional): The max number of features</span>
<span class="sd">                that the CF can vary. Default is no maximum.</span>
<span class="sd">            feature_ranges (dict, optional): A dictionary to control the permitted</span>
<span class="sd">                ranges/values for continuous/categorical features. It maps</span>
<span class="sd">                `feature_name` -&gt; [`min_value`, `max_value`] for continuous features,</span>
<span class="sd">                `feature_name` -&gt; [`level1`, `level2`, ...] for categorical features.</span>
<span class="sd">            continuous_integer_features (list, optional): A list of names of</span>
<span class="sd">                continuous features that need to be integers (e.g., age, FICO score)</span>
<span class="sd">            verbose (bool): True if you want it to print out the optimization</span>
<span class="sd">                process from each iteration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Counterfactuals: The generated counterfactual examples with their</span>
<span class="sd">                associated distances and change information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Transforming some parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_example</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur_example</span> <span class="o">=</span> <span class="n">cur_example</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">features_to_vary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features_to_vary</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;interaction&#39;</span>
            <span class="p">]</span>

        <span class="c1"># Step 1: Find the current score for each feature</span>
        <span class="c1"># This is done by ebm.explain_local()</span>
        <span class="n">cur_scores</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span>

        <span class="n">local_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">explain_local</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)</span><span class="o">.</span><span class="n">_internal_obj</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_data</span><span class="p">[</span><span class="s1">&#39;specific&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;scores&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Find the CF direction</span>

        <span class="c1"># Binary classification</span>
        <span class="c1"># Predicted 0 =&gt; +1</span>
        <span class="c1"># Predicted 1 =&gt; -1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cf_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">total_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cur_scores</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_scores</span><span class="p">])</span>
            <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="o">-</span><span class="n">total_score</span>
            <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regression</span>
            <span class="c1"># Increase +1</span>
            <span class="c1"># Decrease -1</span>
            <span class="k">if</span> <span class="n">target_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;target_range cannot be None when the model is a regressor&#39;</span><span class="p">)</span>

            <span class="n">predicted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">predicted_value</span> <span class="o">&gt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">predicted_value</span> <span class="o">&lt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The target_range cannot cover the current prediction&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">predicted_value</span> <span class="o">&lt;</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>

        <span class="c1"># Step 2: Generate continuous and categorical options</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Generate a similarity threshold if it is not provided</span>
        <span class="k">if</span> <span class="n">sim_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additive_ranges</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">cur_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">additive_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cur_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cur_values</span><span class="p">))</span>

            <span class="n">sim_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">additive_ranges</span><span class="p">)</span> <span class="o">*</span> <span class="n">sim_threshold_factor</span>

        <span class="c1"># To make it faster to solve the MILP problem, we can decrease the</span>
        <span class="c1"># number of variables by filtering out unhelpful and redundant options</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Unhelpful options: options that move the score to an undesirable</span>
        <span class="c1"># direction. For example, if we want to flip 0 to 1, options that decrease</span>
        <span class="c1"># the score are unhelpful.</span>
        <span class="c1">#</span>
        <span class="c1"># (2) Redundant options: for a set of options that give similar score</span>
        <span class="c1"># gains (bounded by a parameter epsilon), we only need to incldue one</span>
        <span class="c1"># option that has the lowest distance. This is only relevant for</span>
        <span class="c1"># continuous variables. Users can set the parameter epsilon. The default</span>
        <span class="c1"># should be relatively small, otherwise we might miss the optimal solution.</span>

        <span class="c1"># Step 2.1: Find all good options from continuous and categorical features</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># The parameter epsilon controls the threshold of how we determine</span>
                <span class="c1"># &quot;similar&quot; options for continuous variables</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">sim_threshold</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>

                <span class="c1"># Users can require the continuous feature to have integer values</span>
                <span class="c1"># For example, age, FICO score, and number of accounts</span>
                <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">continuous_integer_features</span> <span class="ow">and</span> <span class="n">cur_feature_name</span> <span class="ow">in</span> <span class="n">continuous_integer_features</span><span class="p">:</span>
                    <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">cur_cont_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cont_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_name</span><span class="p">,</span>
                    <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">,</span>
                    <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">score_gain_bound</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">need_to_be_int</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cont_options</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>
                <span class="n">cur_cat_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">cur_cat_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cat_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">score_gain_bound</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cat_options</span>

        <span class="c1"># Step 2.2: Filter out undesired options (based on the feature_range)</span>
        <span class="k">if</span> <span class="n">feature_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">feature_ranges</span><span class="p">:</span>
                <span class="n">cur_range</span> <span class="o">=</span> <span class="n">feature_ranges</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="c1"># Delete options that use ineligible options</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">cur_target</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">cur_target</span> <span class="o">&lt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">cur_target</span> <span class="o">&gt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur_range</span><span class="p">:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c1"># Step 2.3: Compute the interaction offsets for all possible options</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">cur_feature_index_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cur_feature_index_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_inter_options</span><span class="p">(</span>
                    <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span> <span class="n">cur_feature_index_2</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span>
                <span class="p">)</span>

        <span class="c1"># Step 2.4: Rescale categorical distances so that they have the same mean</span>
        <span class="c1"># as continuous variables (default)</span>
        <span class="k">if</span> <span class="n">categorical_weight</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">cont_distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cat_distances</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cont_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cat_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">categorical_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cont_distances</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cat_distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
            <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">categorical_weight</span>

        <span class="c1"># Step 3. Formulate the MILP model and solve it</span>

        <span class="c1"># Find diverse solutions by accumulatively muting the optimal solutions</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">muted_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_cfs</span><span class="p">)):</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_milp</span><span class="p">(</span>
                <span class="n">cf_direction</span><span class="p">,</span>
                <span class="n">needed_score_gain</span><span class="p">,</span>
                <span class="n">features_to_vary</span><span class="p">,</span>
                <span class="n">options</span><span class="p">,</span>
                <span class="n">max_num_features_to_vary</span><span class="p">,</span>
                <span class="n">muted_variables</span><span class="o">=</span><span class="n">muted_variables</span>
            <span class="p">)</span>

            <span class="n">model</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">apis</span><span class="o">.</span><span class="n">PULP_CBC_CMD</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">warmStart</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;solver runs for </span><span class="si">{:.2f}</span><span class="s1"> seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">solutionTime</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;status: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">LpStatus</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">]))</span>

            <span class="n">active_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Print the optimal solution</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">varValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">active_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Found solutions:&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_solution</span><span class="p">(</span><span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

            <span class="c1"># Collect the current solution and mute the associated variables</span>
            <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">active_variables</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">objective</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">muted_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">cfs</span> <span class="o">=</span> <span class="n">Counterfactuals</span><span class="p">(</span><span class="n">solutions</span><span class="p">,</span> <span class="n">is_successful</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cfs</span>

    <span class="k">def</span> <span class="nf">generate_cont_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                            <span class="n">cur_feature_name</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                            <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cont_mads</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                            <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                            <span class="n">need_to_be_int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this continuous variable. This function</span>
<span class="sd">        would filter out all options that are:</span>

<span class="sd">        1. Not helpful for the counterfactual generation.</span>
<span class="sd">        2. Give similar score gain but requires larger distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_name (str): Name of the current feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cont_mads (dict): A map of feature_name =&gt; MAD score.</span>
<span class="sd">            cur_example (list): Current sample values</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            epsilon (float): The threshold to determine if two options give similar</span>
<span class="sd">                score gains. Score gains $s_1$ and $s_2$ are similar if</span>
<span class="sd">                $|s_1 - s_2| &lt;$ epsilon. Smaller epsilon significantly increases</span>
<span class="sd">                the time to solve the MILP. Large epsilon might filter out the</span>
<span class="sd">                optimal CF. Defaults to 0.005.</span>
<span class="sd">            need_to_be_int (bool): True if the target values for this continuous</span>
<span class="sd">                variable need to have integer values.</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For each continuous feature, each bin is a variable</span>
        <span class="c1"># For each bin, we need to compute (1) score gain, (2) distance</span>
        <span class="c1"># (1) score gain is the difference between new bin and current bin</span>
        <span class="c1"># (2) distance is L1 distance divided by median absolute deviation (MAD)</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance,</span>
        <span class="c1"># bin_index)</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify which bin this value falls into</span>
        <span class="n">cur_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">additives</span><span class="p">[</span><span class="n">cur_bin_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_score</span><span class="p">)</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                        <span class="n">bin_starts_feature</span><span class="p">,</span> <span class="n">cur_feature_value</span>
                    <span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="c1"># Because of the special binning structure of EBM, the distance of</span>
            <span class="c1"># bins on the left to the current value is different from the bins</span>
            <span class="c1"># that are on the right</span>
            <span class="c1">#</span>
            <span class="c1"># For bins on the left, the raw distance is abs(bin_start[i + 1] - x)</span>
            <span class="c1"># For bins on the right, the raw distance is abs(bin_start[i] - x)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">cur_feature_value</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it is need to be an integer</span>
                <span class="c1"># If so, it would be the closest integer to the right point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="c1"># Subtract a very smaller value to make the target</span>
                    <span class="c1"># technically fall into the left bin</span>
                    <span class="n">target</span> <span class="o">-=</span> <span class="mf">1e-4</span>

            <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it should be an integer value</span>
                <span class="c1"># If so, it would be the closest integer to the left point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

            <span class="c1"># Scale the distance based on the deviation of the feature (how changable it is)</span>
            <span class="k">if</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">/=</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

            <span class="c1"># Compute score gain which has two parts:</span>
            <span class="c1"># (1) gain from the change of main effect</span>
            <span class="c1"># (2) gain from the change of interaction effect</span>

            <span class="c1"># Main effect</span>
            <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

            <span class="c1"># Interaction terms</span>
            <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">],</span> <span class="n">target</span>
                <span class="p">)</span>
                <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

            <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

            <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Filter out of bound options</span>
            <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="n">cont_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="c1"># Now we can apply the second round of filtering to remove redundant options</span>
        <span class="c1"># Redundant options refer to bins that give similar score gain with larger distance</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cont_options</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cont_options</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cont_options</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">cont_options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cont_options</span>

    <span class="k">def</span> <span class="nf">generate_cat_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                             <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span>
                             <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                             <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this categorical variable. This function</span>
<span class="sd">        would filter out all options that are not helpful for the counterfactual</span>
<span class="sd">        generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cur_cat_distance (dict): A map of feature_level =&gt; 1 - frequency.</span>
<span class="sd">            cur_example (list): Current sample values.</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score_gain, distance, bin_index).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find other options for this categorical variable</span>
        <span class="c1"># For each option, we compute the (1) score gain, and (2) distance</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Score gain is the same as continuous variables</span>
        <span class="c1"># (2) The distance is determined by 1 - the level frequency in the</span>
        <span class="c1"># training data. It implies that levels with high frequency are easier</span>
        <span class="c1"># to &quot;move to&quot;</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance, bin_index)</span>
        <span class="n">cat_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>
                    <span class="n">other_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">bin_starts_feature</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feeature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur_feature_value</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">cur_cat_distance</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="c1"># Compute score gain which has two parts:</span>
                <span class="c1"># (1) gain from the change of main effect</span>
                <span class="c1"># (2) gain from the change of interaction effect</span>

                <span class="c1"># Main effect</span>
                <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># Interaction terms</span>
                <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                    <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

                <span class="c1"># Skip unhelpful options</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Filter out of bound options</span>
                <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="n">cat_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cat_options</span>


    <span class="k">def</span> <span class="nf">generate_inter_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span>
                               <span class="n">cur_feature_index_2</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all possible options for this interaction variable.</span>

<span class="sd">        Interaction terms are interesting in this MILP. Each option counts as a</span>
<span class="sd">        variable, but each variable only affects the score gain, not the distance.</span>

<span class="sd">        Note that in EBM, the bin definitions for interaction terms can be different</span>
<span class="sd">        from their defintiions for individual continuous variables.</span>

<span class="sd">        To model interaction terms, we can think it as a binary variable. The</span>
<span class="sd">        value is determined by the multiplication of two main effect variables.</span>
<span class="sd">        Each interaction variable describes a combination of two main effect</span>
<span class="sd">        variables. Therefore, say continuous variable A has $x$ probable options,</span>
<span class="sd">        and another continuous variable B has $y$ probable options, then we should</span>
<span class="sd">        add $x \\times y$ binary variables to offset their probable interaction</span>
<span class="sd">        effects.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_feature_id (int): The id of this interaction effect.</span>
<span class="sd">            cur_feature_index_1 (int): The index of the first main effect.</span>
<span class="sd">            cur_feature_index_2 (int): The index of the second main effect.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            options (dict): The current option list, feature_name -&gt;</span>
<span class="sd">                [`target`, `score_gain`, `distance`, `bin_id`].</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of option tuples (target, score_gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the sub-types for this interaction term</span>
        <span class="n">cur_feature_type_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_type_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># Get the sub-names for this interaction term</span>
        <span class="n">cur_feature_name_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_name_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># The first column and row are reserved for missing values (even with</span>
        <span class="c1"># categorical features)</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Four possibilities here: cont x cont, cont x cat, cat x cont, cat x cat.</span>
        <span class="c1"># Each has a different way to lookup the bin table.</span>
        <span class="n">inter_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through all possible combinations of options from these two</span>
        <span class="c1"># variables</span>
        <span class="k">for</span> <span class="n">opt_1</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">opt_2</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_2</span><span class="p">]:</span>

                <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_1</span><span class="p">)</span>
                <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_2</span><span class="p">)</span>

                <span class="n">bin_1</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">bin_2</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">cur_feature_type_1</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cont x cont</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cont x cat</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cat x cont</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cat x cat</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">new_score</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">bin_1</span><span class="p">,</span> <span class="n">bin_2</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">new_score</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># The score gain on the interaction term need to offset the interaction</span>
                <span class="c1"># score gain we have already counted on the main effect options. That</span>
                <span class="c1"># score is saved in the option tuple.</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

                <span class="c1"># Optimization: here we cannot comapre the score_gain with</span>
                <span class="c1"># original interaction score to filter interaction options,</span>
                <span class="c1"># because the choice of two individual main effects do not</span>
                <span class="c1"># consier this interaction score</span>
                <span class="c1">#</span>
                <span class="c1"># Basically, the score gain of one interaction effect does</span>
                <span class="c1"># not affect the way we choose options for the main</span>
                <span class="c1"># variables. Only the solver can decide that :(</span>

                <span class="n">inter_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">score_gain</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
                    <span class="mi">0</span>
                <span class="p">])</span>

        <span class="k">return</span> <span class="n">inter_options</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_milp</span><span class="p">(</span><span class="n">cf_direction</span><span class="p">,</span> <span class="n">needed_score_gain</span><span class="p">,</span> <span class="n">features_to_vary</span><span class="p">,</span>
                    <span class="n">options</span><span class="p">,</span> <span class="n">max_num_features_to_vary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">muted_variables</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MILP to find counterfactuals (CF) using PuLP.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer +1 if 0 =&gt; 1, -1 if 1 =&gt; 0 (classification),</span>
<span class="sd">                +1 if we need to incrase the prediction, -1 if decrease (regression).</span>
<span class="sd">            needed_score_gain (float): The score gain needed to achieve the CF goal.</span>
<span class="sd">            features_to_vary (list[str]): Feature names of features that the</span>
<span class="sd">                generated CF can change.</span>
<span class="sd">            options (dict): Possible options for each variable. Each option is a</span>
<span class="sd">                list [target, score_gain, distance, bin_index].</span>
<span class="sd">            max_num_features_to_vary (int, optional): Max number of features that the</span>
<span class="sd">                generated CF can change. If the value is `None`, the CFs can</span>
<span class="sd">                change any number of features.</span>
<span class="sd">            muted_variables (list[str], optional): Variables that this MILP should</span>
<span class="sd">                not use. This is useful to mute optimal variables so we can explore</span>
<span class="sd">                diverse solutions. This list should not include interaction variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (`model`, `variables`), where `model` is a pulp.LpProblem</span>
<span class="sd">            model that encodes the MILP problem, and `variables` is a dict of</span>
<span class="sd">            variables used in the `model`: `feature_name` =&gt; [`variables`].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a model (minimizing the distance)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpProblem</span><span class="p">(</span><span class="s1">&#39;ebmCounterfactual&#39;</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpMinimize</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">score_gain</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">muted_variables_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">muted_variables</span><span class="p">)</span>

        <span class="c1"># Create variables</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>
            <span class="c1"># Each variable encodes an option (0: not use this option,</span>
            <span class="c1"># 1: use this option)</span>
            <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

                <span class="c1"># Skip the muted variables</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span>
                                    <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Binary&#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">score_gain</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>

                <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

            <span class="c1"># A local constraint is that we can only at most selection one option from</span>
            <span class="c1"># one feature</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">cur_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>

        <span class="c1"># Users can also set `max_num_features_to_vary` to control the total</span>
        <span class="c1"># number of features to vary</span>
        <span class="k">if</span> <span class="n">max_num_features_to_vary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">main_variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">main_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_num_features_to_vary</span>

        <span class="c1"># Create variables for interaction effects</span>
        <span class="k">for</span> <span class="n">opt_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">in</span> <span class="n">opt_name</span><span class="p">:</span>
                <span class="n">f1_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+)\sx\s.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>
                <span class="n">f2_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+\sx\s(.+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">f1_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span> <span class="ow">and</span> <span class="n">f2_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>

                    <span class="c1"># We need to include this interaction effect</span>
                    <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opt_name</span><span class="p">,</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
                                            <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Continuous&#39;</span><span class="p">)</span>
                        <span class="n">z</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># Need to iterate through existing variables for f1 and f2 to find</span>
                        <span class="c1"># the corresponding variables</span>
                        <span class="n">x_f1</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">x_f2</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="c1"># Skp if this interaction variable involves muted main variable</span>
                        <span class="n">x_f1_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">x_f2_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f2_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">x_f1_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span> <span class="ow">or</span> <span class="n">x_f2_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f1_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f1_name</span><span class="p">:</span>
                                <span class="n">x_f1</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f2_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f2_name</span><span class="p">:</span>
                                <span class="n">x_f2</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">assert</span><span class="p">(</span><span class="n">x_f1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x_f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

                        <span class="c1"># variable z is actually the product of x_f1 and x_f2</span>
                        <span class="c1"># We can linearize it by 3 constraints</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f1</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f2</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">x_f1</span> <span class="o">+</span> <span class="n">x_f2</span> <span class="o">-</span> <span class="mi">1</span>

                        <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                    <span class="n">variables</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

        <span class="c1"># Use constraint to express counterfactual</span>
        <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&gt;=</span> <span class="n">needed_score_gain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="n">needed_score_gain</span>

        <span class="c1"># We want to minimize the distance</span>
        <span class="n">model</span> <span class="o">+=</span> <span class="n">distance</span>

        <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span>

    <span class="k">def</span> <span class="nf">print_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the optimal solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): the original data point.</span>
<span class="sd">            active_variables (list[variable]): binary variables with value 1.</span>
<span class="sd">            options (dict): all the possible options for all features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
            <span class="c1"># Skip interaction vars (included)</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">bin_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="c1"># Find the original value</span>
                <span class="n">org_value</span> <span class="o">=</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span>

                <span class="c1"># Find the target bin</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">f_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">):</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; inf)&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">org_value</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">org_value</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_i</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Change &lt;</span><span class="si">{}</span><span class="s1">&gt; from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span><span class="p">,</span> <span class="n">org_value</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_bin</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="p">))</span>
                        <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">f_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_x_&#39;</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="p">)</span>
                <span class="n">bin_0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+),\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">bin_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:\d+,(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_0</span> <span class="ow">and</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trigger interaction term: &lt;</span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span>
                        <span class="p">))</span>
                        <span class="k">break</span>
        <span class="nb">print</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_mad</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the median absolute deviation of a continuous feature.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of continuous values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: MAD value of xs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">xs_median</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mad</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_frequency_distance</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For categorical variables, we compute 1 - frequency as their distance. It implies</span>
<span class="sd">        that switching to a frequent value takes less effort.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of categorical values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: category level -&gt; 1 - frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span>
</pre></div>

        </details>

            <div class="docstring"><p>Main class for GAM Coach.</p>
</div>


                            <div id="GAMCoach.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GAMCoach</span><span class="signature">(
    ebm: Union[interpret.glassbox.ebm.ebm.ExplainableBoostingClassifier, interpret.glassbox.ebm.ebm.ExplainableBoostingRegressor],
    x_train: numpy.ndarray,
    cont_mads=None,
    cat_distances=None
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">],</span>
                 <span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                 <span class="n">cont_mads</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">cat_distances</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize a GAMCoach object.</span>

<span class="sd">        Args:</span>
<span class="sd">            ebm (Union[ExplainableBoostingClassifier, ExplainableBoostingRegressor]):</span>
<span class="sd">                The trained EBM model. It can be either a classifier or a regressor.</span>
<span class="sd">            x_train (np.ndarray): The training data. It is used to compute the</span>
<span class="sd">                distance for different features.</span>
<span class="sd">            cont_mads (dict, optional): `feature_name` -&gt; `median absolute</span>
<span class="sd">                deviation score`. If it is provided, it is used to overwrite the</span>
<span class="sd">                computed MADs for continuous variables. It is useful when you</span>
<span class="sd">                want to provide a custom normalization function to compute the</span>
<span class="sd">                distance between continuous features.</span>
<span class="sd">            cat_distances (dict, optional): `feature_name` -&gt; {`level_name` -&gt; `distance`}.</span>
<span class="sd">                Level distance of categorical variables. By default, the distance</span>
<span class="sd">                is computed by (1 - frequency(level)) for each level. It imples</span>
<span class="sd">                that it is easier to move to a more frequent. If `cat_distances`</span>
<span class="sd">                is provided, it will overwrite the default distance for</span>
<span class="sd">                categorical variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">ExplainableBoostingClassifier</span><span class="p">,</span> <span class="n">ExplainableBoostingRegressor</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span>
        <span class="sd">&quot;&quot;&quot;The trained EBM model.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span> <span class="o">=</span> <span class="n">x_train</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cont_mads</span>
        <span class="sd">&quot;&quot;&quot;Median absolute deviation (MAD) of continuous variables.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">cat_distances</span>
        <span class="sd">&quot;&quot;&quot;Level distance of categorical variables. By default, the distance is</span>
<span class="sd">        computed by $(1 - \\frac{\\text{count of} L_i}{\\text{count of all L}})$</span>
<span class="sd">        for one level $L_i$. It implies that it is easier to move to a more</span>
<span class="sd">        frequent level.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If cont_mads is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cont_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cont_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">[</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

        <span class="c1"># If cat_distance is not given, we compute it from the training data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ebm_cat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))</span>
                 <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span> <span class="o">=</span> <span class="p">{}</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cat_indexes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_frequency_distance</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
                <span class="p">)</span>

        <span class="c1"># Determine if the ebm is a classifier or a regressor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="sd">&quot;&quot;&quot;True if the ebm model is a classifier, false if it is a regressor.&quot;&quot;&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initialize a GAMCoach object.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>ebm (Union[ExplainableBoostingClassifier, ExplainableBoostingRegressor]):</strong>  The trained EBM model. It can be either a classifier or a regressor.</li>
<li><strong>x_train (np.ndarray):</strong>  The training data. It is used to compute the
distance for different features.</li>
<li><strong>cont_mads (dict, optional):</strong>  <code>feature_name</code> -> <code>median absolute
deviation score</code>. If it is provided, it is used to overwrite the
computed MADs for continuous variables. It is useful when you
want to provide a custom normalization function to compute the
distance between continuous features.</li>
<li><strong>cat_distances (dict, optional):</strong>  <code>feature_name</code> -> {<code>level_name</code> -> <code>distance</code>}.
Level distance of categorical variables. By default, the distance
is computed by (1 - frequency(level)) for each level. It imples
that it is easier to move to a more frequent. If <code><a href="#GAMCoach.cat_distances">cat_distances</a></code>
is provided, it will overwrite the default distance for
categorical variables.</li>
</ul>
</div>


                            </div>
                            <div id="GAMCoach.ebm" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GAMCoach.ebm">#&nbsp;&nbsp</a>

        <span class="name">ebm</span><span class="annotation">: Union[interpret.glassbox.ebm.ebm.ExplainableBoostingClassifier, interpret.glassbox.ebm.ebm.ExplainableBoostingRegressor]</span>
    </div>

            <div class="docstring"><p>The trained EBM model.</p>
</div>


                            </div>
                            <div id="GAMCoach.cont_mads" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GAMCoach.cont_mads">#&nbsp;&nbsp</a>

        <span class="name">cont_mads</span><span class="annotation">: dict</span>
    </div>

            <div class="docstring"><p>Median absolute deviation (MAD) of continuous variables.</p>
</div>


                            </div>
                            <div id="GAMCoach.cat_distances" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GAMCoach.cat_distances">#&nbsp;&nbsp</a>

        <span class="name">cat_distances</span><span class="annotation">: dict</span>
    </div>

            <div class="docstring"><p>Level distance of categorical variables. By default, the distance is
computed by $(1 - \frac{\text{count of} L_i}{\text{count of all L}})$
for one level $L_i$. It implies that it is easier to move to a more
frequent level.</p>
</div>


                            </div>
                            <div id="GAMCoach.is_classifier" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GAMCoach.is_classifier">#&nbsp;&nbsp</a>

        <span class="name">is_classifier</span>
    </div>

            <div class="docstring"><p>True if the ebm model is a classifier, false if it is a regressor.</p>
</div>


                            </div>
                            <div id="GAMCoach.generate_cfs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.generate_cfs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_cfs</span><span class="signature">(
    self,
    cur_example: numpy.ndarray,
    total_cfs: int = 1,
    target_range: tuple = None,
    sim_threshold_factor: float = 0.005,
    sim_threshold: float = None,
    categorical_weight: Union[float, str] = &#39;auto&#39;,
    features_to_vary: list = None,
    max_num_features_to_vary: int = None,
    feature_ranges: dict = None,
    continuous_integer_features: list = None,
    verbose: bool = False
) -&gt; <a href="counterfactuals.html#Counterfactuals">gamcoach.counterfactuals.Counterfactuals</a></span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_cfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">cur_example</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span>
                     <span class="n">total_cfs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="n">target_range</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">sim_threshold_factor</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
                     <span class="n">sim_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">categorical_weight</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                     <span class="n">features_to_vary</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">max_num_features_to_vary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">feature_ranges</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">continuous_integer_features</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counterfactuals</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Generate counterfactual examples.</span>

<span class="sd">        Use mixed-integer linear programming to generate optimal counterfactual</span>
<span class="sd">        examples for the given data point.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): The data point of interest. This function</span>
<span class="sd">                aims to find similar examples that the model gives different</span>
<span class="sd">                predictions.</span>
<span class="sd">            total_cfs (int, optional): The total number of counterfactuals to,</span>
<span class="sd">                generate. Default to 1.</span>
<span class="sd">            target_range (tuple, optional): The targetted prediction range. This</span>
<span class="sd">                parameter is required if the EBM is a regressor.</span>
<span class="sd">            sim_threshold_factor (float, optional): A positive float to automatically</span>
<span class="sd">                generate a similarity threshold. This parameter has no effect if</span>
<span class="sd">                `sim_threshold` is provided. If `sim_threshold` is</span>
<span class="sd">                not provided, we compute `sim_threshold` as `sim_threshold_factor`</span>
<span class="sd">                * average additive score range of all continuous features. If</span>
<span class="sd">                `sim_threshold_factor` is too small, it takes longer time to</span>
<span class="sd">                generate CFs. If `sim_threshold_factor` is too large, the</span>
<span class="sd">                algorithm might miss some optimal CFs.</span>
<span class="sd">            sim_threshold (float, optional): A positive float to determine how we</span>
<span class="sd">                decide if two bins of a continuous feature have similar scores.</span>
<span class="sd">                Two bins $b_1$ and $b_2$ are similar (the distant one will be</span>
<span class="sd">                removed) if $|b_1 - b_2| \\leq$ `sim_threshold`.</span>
<span class="sd">            categorical_weight (Union[float, str], optional): A positive float</span>
<span class="sd">                to scale the distances of options for categorical variables. Since</span>
<span class="sd">                we have very different distance functions for continuous and</span>
<span class="sd">                categorical features, we need to scale them so they are at a</span>
<span class="sd">                comparable range. To do that, we multiply the categorical feature&#39;s</span>
<span class="sd">                distances by `categorical_weight`. By default (&#39;auto&#39;), we scale</span>
<span class="sd">                the distances of categorical features so that they have the mean</span>
<span class="sd">                distance as continuous features.</span>
<span class="sd">            features_to_vary ([str], optional): A list of feature names that</span>
<span class="sd">                the CFs can change. If it is `None`, this function will use all</span>
<span class="sd">                features.</span>
<span class="sd">            max_num_features_to_vary (int, optional): The max number of features</span>
<span class="sd">                that the CF can vary. Default is no maximum.</span>
<span class="sd">            feature_ranges (dict, optional): A dictionary to control the permitted</span>
<span class="sd">                ranges/values for continuous/categorical features. It maps</span>
<span class="sd">                `feature_name` -&gt; [`min_value`, `max_value`] for continuous features,</span>
<span class="sd">                `feature_name` -&gt; [`level1`, `level2`, ...] for categorical features.</span>
<span class="sd">            continuous_integer_features (list, optional): A list of names of</span>
<span class="sd">                continuous features that need to be integers (e.g., age, FICO score)</span>
<span class="sd">            verbose (bool): True if you want it to print out the optimization</span>
<span class="sd">                process from each iteration.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Counterfactuals: The generated counterfactual examples with their</span>
<span class="sd">                associated distances and change information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Transforming some parameters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cur_example</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cur_example</span> <span class="o">=</span> <span class="n">cur_example</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">features_to_vary</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">features_to_vary</span> <span class="o">=</span> <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;interaction&#39;</span>
            <span class="p">]</span>

        <span class="c1"># Step 1: Find the current score for each feature</span>
        <span class="c1"># This is done by ebm.explain_local()</span>
        <span class="n">cur_scores</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_scores</span><span class="p">[</span><span class="s1">&#39;intercept&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span>

        <span class="n">local_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">explain_local</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)</span><span class="o">.</span><span class="n">_internal_obj</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">local_data</span><span class="p">[</span><span class="s1">&#39;specific&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;scores&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Find the CF direction</span>

        <span class="c1"># Binary classification</span>
        <span class="c1"># Predicted 0 =&gt; +1</span>
        <span class="c1"># Predicted 1 =&gt; -1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_classifier</span><span class="p">:</span>
            <span class="n">cf_direction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">total_score</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">cur_scores</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_scores</span><span class="p">])</span>
            <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="o">-</span><span class="n">total_score</span>
            <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Regression</span>
            <span class="c1"># Increase +1</span>
            <span class="c1"># Decrease -1</span>
            <span class="k">if</span> <span class="n">target_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;target_range cannot be None when the model is a regressor&#39;</span><span class="p">)</span>

            <span class="n">predicted_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">cur_example</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">predicted_value</span> <span class="o">&gt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">predicted_value</span> <span class="o">&lt;=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The target_range cannot cover the current prediction&#39;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">predicted_value</span> <span class="o">&lt;</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cf_direction</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">needed_score_gain</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>
                <span class="n">score_gain_bound</span> <span class="o">=</span> <span class="n">target_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">predicted_value</span>

        <span class="c1"># Step 2: Generate continuous and categorical options</span>
        <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Generate a similarity threshold if it is not provided</span>
        <span class="k">if</span> <span class="n">sim_threshold</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">additive_ranges</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">cur_values</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">additive_ranges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cur_values</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cur_values</span><span class="p">))</span>

            <span class="n">sim_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">additive_ranges</span><span class="p">)</span> <span class="o">*</span> <span class="n">sim_threshold_factor</span>

        <span class="c1"># To make it faster to solve the MILP problem, we can decrease the</span>
        <span class="c1"># number of variables by filtering out unhelpful and redundant options</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Unhelpful options: options that move the score to an undesirable</span>
        <span class="c1"># direction. For example, if we want to flip 0 to 1, options that decrease</span>
        <span class="c1"># the score are unhelpful.</span>
        <span class="c1">#</span>
        <span class="c1"># (2) Redundant options: for a set of options that give similar score</span>
        <span class="c1"># gains (bounded by a parameter epsilon), we only need to incldue one</span>
        <span class="c1"># option that has the lowest distance. This is only relevant for</span>
        <span class="c1"># continuous variables. Users can set the parameter epsilon. The default</span>
        <span class="c1"># should be relatively small, otherwise we might miss the optimal solution.</span>

        <span class="c1"># Step 2.1: Find all good options from continuous and categorical features</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># The parameter epsilon controls the threshold of how we determine</span>
                <span class="c1"># &quot;similar&quot; options for continuous variables</span>
                <span class="n">epsilon</span> <span class="o">=</span> <span class="n">sim_threshold</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>

                <span class="c1"># Users can require the continuous feature to have integer values</span>
                <span class="c1"># For example, age, FICO score, and number of accounts</span>
                <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">continuous_integer_features</span> <span class="ow">and</span> <span class="n">cur_feature_name</span> <span class="ow">in</span> <span class="n">continuous_integer_features</span><span class="p">:</span>
                    <span class="n">need_to_be_int</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="n">cur_cont_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cont_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_name</span><span class="p">,</span>
                    <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cont_mads</span><span class="p">,</span>
                    <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">score_gain_bound</span><span class="p">,</span> <span class="n">epsilon</span><span class="p">,</span> <span class="n">need_to_be_int</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cont_options</span>

            <span class="k">elif</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>
                <span class="n">cur_feature_value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">cur_feature_id</span><span class="p">])</span>
                <span class="n">cur_cat_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_distances</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">cur_cat_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_cat_options</span><span class="p">(</span>
                    <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">score_gain_bound</span>
                <span class="p">)</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_cat_options</span>

        <span class="c1"># Step 2.2: Filter out undesired options (based on the feature_range)</span>
        <span class="k">if</span> <span class="n">feature_ranges</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">feature_ranges</span><span class="p">:</span>
                <span class="n">cur_range</span> <span class="o">=</span> <span class="n">feature_ranges</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="c1"># Delete options that use ineligible options</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="n">cur_target</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">cur_target</span> <span class="o">&lt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">cur_target</span> <span class="o">&gt;</span> <span class="n">cur_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">][</span><span class="n">o</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cur_range</span><span class="p">:</span>
                            <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="c1"># Step 2.3: Compute the interaction offsets for all possible options</span>
        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>

            <span class="n">cur_feature_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">cur_feature_index_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">cur_feature_index_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">cur_feature_score</span> <span class="o">=</span> <span class="n">cur_scores</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

                <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">generate_inter_options</span><span class="p">(</span>
                    <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span> <span class="n">cur_feature_index_2</span><span class="p">,</span>
                    <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span>
                <span class="p">)</span>

        <span class="c1"># Step 2.4: Rescale categorical distances so that they have the same mean</span>
        <span class="c1"># as continuous variables (default)</span>
        <span class="k">if</span> <span class="n">categorical_weight</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">cont_distances</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cat_distances</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cont_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                        <span class="n">cat_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">categorical_weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cont_distances</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cat_distances</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">f_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
            <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">categorical_weight</span>

        <span class="c1"># Step 3. Formulate the MILP model and solve it</span>

        <span class="c1"># Find diverse solutions by accumulatively muting the optimal solutions</span>
        <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">muted_variables</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">total_cfs</span><span class="p">)):</span>
            <span class="n">model</span><span class="p">,</span> <span class="n">variables</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_milp</span><span class="p">(</span>
                <span class="n">cf_direction</span><span class="p">,</span>
                <span class="n">needed_score_gain</span><span class="p">,</span>
                <span class="n">features_to_vary</span><span class="p">,</span>
                <span class="n">options</span><span class="p">,</span>
                <span class="n">max_num_features_to_vary</span><span class="p">,</span>
                <span class="n">muted_variables</span><span class="o">=</span><span class="n">muted_variables</span>
            <span class="p">)</span>

            <span class="n">model</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">apis</span><span class="o">.</span><span class="n">PULP_CBC_CMD</span><span class="p">(</span><span class="n">msg</span><span class="o">=</span><span class="n">verbose</span><span class="p">,</span> <span class="n">warmStart</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">is_successful</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;solver runs for </span><span class="si">{:.2f}</span><span class="s1"> seconds&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">solutionTime</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;status: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pulp</span><span class="o">.</span><span class="n">LpStatus</span><span class="p">[</span><span class="n">model</span><span class="o">.</span><span class="n">status</span><span class="p">]))</span>

            <span class="n">active_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># Print the optimal solution</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">varValue</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">active_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Found solutions:&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">print_solution</span><span class="p">(</span><span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

            <span class="c1"># Collect the current solution and mute the associated variables</span>
            <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">active_variables</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">objective</span><span class="p">)])</span>

            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="n">muted_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="n">cfs</span> <span class="o">=</span> <span class="n">Counterfactuals</span><span class="p">(</span><span class="n">solutions</span><span class="p">,</span> <span class="n">is_successful</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span>
                              <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">cfs</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generate counterfactual examples.</p>

<p>Use mixed-integer linear programming to generate optimal counterfactual
examples for the given data point.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cur_example (np.ndarray):</strong>  The data point of interest. This function
aims to find similar examples that the model gives different
predictions.</li>
<li><strong>total_cfs (int, optional):</strong>  The total number of counterfactuals to,
generate. Default to 1.</li>
<li><strong>target_range (tuple, optional):</strong>  The targetted prediction range. This
parameter is required if the EBM is a regressor.</li>
<li><strong>sim_threshold_factor (float, optional):</strong>  A positive float to automatically
generate a similarity threshold. This parameter has no effect if
<code>sim_threshold</code> is provided. If <code>sim_threshold</code> is
not provided, we compute <code>sim_threshold</code> as <code>sim_threshold_factor</code>
<ul>
<li>average additive score range of all continuous features. If
<code>sim_threshold_factor</code> is too small, it takes longer time to
generate CFs. If <code>sim_threshold_factor</code> is too large, the
algorithm might miss some optimal CFs.</li>
</ul></li>
<li><strong>sim_threshold (float, optional):</strong>  A positive float to determine how we
decide if two bins of a continuous feature have similar scores.
Two bins $b_1$ and $b_2$ are similar (the distant one will be
removed) if $|b_1 - b_2| \leq$ <code>sim_threshold</code>.</li>
<li><strong>categorical_weight (Union[float, str], optional):</strong>  A positive float
to scale the distances of options for categorical variables. Since
we have very different distance functions for continuous and
categorical features, we need to scale them so they are at a
comparable range. To do that, we multiply the categorical feature's
distances by <code>categorical_weight</code>. By default ('auto'), we scale
the distances of categorical features so that they have the mean
distance as continuous features.</li>
<li><strong>features_to_vary ([str], optional):</strong>  A list of feature names that
the CFs can change. If it is <code>None</code>, this function will use all
features.</li>
<li><strong>max_num_features_to_vary (int, optional):</strong>  The max number of features
that the CF can vary. Default is no maximum.</li>
<li><strong>feature_ranges (dict, optional):</strong>  A dictionary to control the permitted
ranges/values for continuous/categorical features. It maps
<code>feature_name</code> -> [<code>min_value</code>, <code>max_value</code>] for continuous features,
<code>feature_name</code> -> [<code>level1</code>, <code>level2</code>, ...] for categorical features.</li>
<li><strong>continuous_integer_features (list, optional):</strong>  A list of names of
continuous features that need to be integers (e.g., age, FICO score)</li>
<li><strong>verbose (bool):</strong>  True if you want it to print out the optimization
process from each iteration.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>Counterfactuals: The generated counterfactual examples with their
      associated distances and change information.</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.generate_cont_options" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.generate_cont_options">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_cont_options</span><span class="signature">(
    self,
    cf_direction,
    cur_feature_index,
    cur_feature_name,
    cur_feature_value,
    cur_feature_score,
    cont_mads,
    cur_example,
    score_gain_bound=None,
    epsilon=0.005,
    need_to_be_int=False,
    skip_unhelpful=True
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_cont_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                            <span class="n">cur_feature_name</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">,</span>
                            <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">cont_mads</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                            <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">epsilon</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                            <span class="n">need_to_be_int</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this continuous variable. This function</span>
<span class="sd">        would filter out all options that are:</span>

<span class="sd">        1. Not helpful for the counterfactual generation.</span>
<span class="sd">        2. Give similar score gain but requires larger distance.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_name (str): Name of the current feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cont_mads (dict): A map of feature_name =&gt; MAD score.</span>
<span class="sd">            cur_example (list): Current sample values</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            epsilon (float): The threshold to determine if two options give similar</span>
<span class="sd">                score gains. Score gains $s_1$ and $s_2$ are similar if</span>
<span class="sd">                $|s_1 - s_2| &lt;$ epsilon. Smaller epsilon significantly increases</span>
<span class="sd">                the time to solve the MILP. Large epsilon might filter out the</span>
<span class="sd">                optimal CF. Defaults to 0.005.</span>
<span class="sd">            need_to_be_int (bool): True if the target values for this continuous</span>
<span class="sd">                variable need to have integer values.</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># For each continuous feature, each bin is a variable</span>
        <span class="c1"># For each bin, we need to compute (1) score gain, (2) distance</span>
        <span class="c1"># (1) score gain is the difference between new bin and current bin</span>
        <span class="c1"># (2) distance is L1 distance divided by median absolute deviation (MAD)</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance,</span>
        <span class="c1"># bin_index)</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify which bin this value falls into</span>
        <span class="n">cur_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">,</span> <span class="n">cur_feature_value</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">additives</span><span class="p">[</span><span class="n">cur_bin_id</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_score</span><span class="p">)</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                        <span class="n">bin_starts_feature</span><span class="p">,</span> <span class="n">cur_feature_value</span>
                    <span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="c1"># Because of the special binning structure of EBM, the distance of</span>
            <span class="c1"># bins on the left to the current value is different from the bins</span>
            <span class="c1"># that are on the right</span>
            <span class="c1">#</span>
            <span class="c1"># For bins on the left, the raw distance is abs(bin_start[i + 1] - x)</span>
            <span class="c1"># For bins on the right, the raw distance is abs(bin_start[i] - x)</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">cur_feature_value</span>
            <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it is need to be an integer</span>
                <span class="c1"># If so, it would be the closest integer to the right point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">-=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">&lt;</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="c1"># Subtract a very smaller value to make the target</span>
                    <span class="c1"># technically fall into the left bin</span>
                    <span class="n">target</span> <span class="o">-=</span> <span class="mf">1e-4</span>

            <span class="k">elif</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">cur_bin_id</span><span class="p">:</span>
                <span class="c1"># First need to consier if it should be an integer value</span>
                <span class="c1"># If so, it would be the closest integer to the left point</span>
                <span class="k">if</span> <span class="n">need_to_be_int</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">target</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># Skip this option if it is not possible to find an int value</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)</span> <span class="ow">and</span> <span class="n">target</span> <span class="o">&gt;=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                        <span class="k">continue</span>

                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target</span> <span class="o">=</span> <span class="n">bin_starts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">target</span> <span class="o">-</span> <span class="n">cur_feature_value</span><span class="p">)</span>

            <span class="c1"># Scale the distance based on the deviation of the feature (how changable it is)</span>
            <span class="k">if</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">distance</span> <span class="o">/=</span> <span class="n">cont_mads</span><span class="p">[</span><span class="n">cur_feature_name</span><span class="p">]</span>

            <span class="c1"># Compute score gain which has two parts:</span>
            <span class="c1"># (1) gain from the change of main effect</span>
            <span class="c1"># (2) gain from the change of interaction effect</span>

            <span class="c1"># Main effect</span>
            <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

            <span class="c1"># Interaction terms</span>
            <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">],</span> <span class="n">target</span>
                <span class="p">)</span>
                <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                    <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

            <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

            <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Filter out of bound options</span>
            <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="n">cont_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="c1"># Now we can apply the second round of filtering to remove redundant options</span>
        <span class="c1"># Redundant options refer to bins that give similar score gain with larger distance</span>
        <span class="n">cont_options</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cont_options</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cont_options</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cont_options</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">cont_options</span><span class="p">[</span><span class="n">start</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">epsilon</span><span class="p">:</span>
                    <span class="n">cont_options</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="n">start</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">cont_options</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generage all alternative options for this continuous variable. This function
would filter out all options that are:</p>

<ol>
<li>Not helpful for the counterfactual generation.</li>
<li>Give similar score gain but requires larger distance.</li>
</ol>

<h6 id="args">Args</h6>

<ul>
<li><strong>cf_direction (int):</strong>  Integer <code>+1</code> if 0 =&gt; 1, <code>-1</code> if 1 =&gt; 0
(classification); <code>+1</code> if we need to incrase the prediction,
<code>-1</code> if decrease (regression).</li>
<li><strong>cur_feature_index (int):</strong>  The index of the current continuous feature.</li>
<li><strong>cur_feature_name (str):</strong>  Name of the current feature.</li>
<li><strong>cur_feature_value (float):</strong>  The current feature value.</li>
<li><strong>cur_feature_score (float):</strong>  The score for the current feature value.</li>
<li><strong>cont_mads (dict):</strong>  A map of feature_name =&gt; MAD score.</li>
<li><strong>cur_example (list):</strong>  Current sample values</li>
<li><strong>score_gain_bound (float):</strong>  Bound of the score gain. We do not collect
options that give <code>score_gain</code> &gt; <code>score_gain_bound</code> (when
<code>cf_direction=1</code>), or <code>score_gain</code> &lt; <code>score_gain_bound</code> (when
<code>cf_direction=-1</code>)</li>
<li><strong>epsilon (float):</strong>  The threshold to determine if two options give similar
score gains. Score gains $s_1$ and $s_2$ are similar if
$|s_1 - s_2| <$ epsilon. Smaller epsilon significantly increases
the time to solve the MILP. Large epsilon might filter out the
optimal CF. Defaults to 0.005.</li>
<li><strong>need_to_be_int (bool):</strong>  True if the target values for this continuous
variable need to have integer values.</li>
<li><strong>skip_unhelpful (bool):</strong>  True if to skip options from main
effects that give opposite score gain. It is rare that there is a
positive score gain from pair-interaction that outweigh negative
score gain from two main effects, and adjusting the distance penalty.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>list: List of option tuples (target, score gain, distance, bin_index)</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.generate_cat_options" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.generate_cat_options">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_cat_options</span><span class="signature">(
    self,
    cf_direction,
    cur_feature_index,
    cur_feature_value,
    cur_feature_score,
    cur_cat_distance,
    cur_example,
    score_gain_bound=None,
    skip_unhelpful=True
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_cat_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cf_direction</span><span class="p">,</span> <span class="n">cur_feature_index</span><span class="p">,</span>
                             <span class="n">cur_feature_value</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span>
                             <span class="n">cur_cat_distance</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span>
                             <span class="n">score_gain_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">skip_unhelpful</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all alternative options for this categorical variable. This function</span>
<span class="sd">        would filter out all options that are not helpful for the counterfactual</span>
<span class="sd">        generation.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer `+1` if 0 =&gt; 1, `-1` if 1 =&gt; 0</span>
<span class="sd">                (classification); `+1` if we need to incrase the prediction,</span>
<span class="sd">                `-1` if decrease (regression).</span>
<span class="sd">            cur_feature_index (int): The index of the current continuous feature.</span>
<span class="sd">            cur_feature_value (float): The current feature value.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            cur_cat_distance (dict): A map of feature_level =&gt; 1 - frequency.</span>
<span class="sd">            cur_example (list): Current sample values.</span>
<span class="sd">            score_gain_bound (float): Bound of the score gain. We do not collect</span>
<span class="sd">                options that give `score_gain` &gt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=1`), or `score_gain` &lt; `score_gain_bound` (when</span>
<span class="sd">                `cf_direction=-1`)</span>
<span class="sd">            skip_unhelpful (bool): True if to skip options from main</span>
<span class="sd">                effects that give opposite score gain. It is rare that there is a</span>
<span class="sd">                positive score gain from pair-interaction that outweigh negative</span>
<span class="sd">                score gain from two main effects, and adjusting the distance penalty.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of option tuples (target, score_gain, distance, bin_index).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Find other options for this categorical variable</span>
        <span class="c1"># For each option, we compute the (1) score gain, and (2) distance</span>
        <span class="c1">#</span>
        <span class="c1"># (1) Score gain is the same as continuous variables</span>
        <span class="c1"># (2) The distance is determined by 1 - the level frequency in the</span>
        <span class="c1"># training data. It implies that levels with high frequency are easier</span>
        <span class="c1"># to &quot;move to&quot;</span>

        <span class="c1"># Get the additive scores of this feature</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Get the bin edges of this feature</span>
        <span class="n">levels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index</span><span class="p">)</span>

        <span class="c1"># Create &quot;options&quot;, each option is a tuple (target, score_gain, distance, bin_index)</span>
        <span class="n">cat_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Identify interaction terms that we need to consider</span>
        <span class="n">associated_interactions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">cur_feature_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
            <span class="n">cur_feature_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cur_feature_type</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>

                <span class="n">indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">cur_feature_index</span> <span class="ow">in</span> <span class="n">indexes</span><span class="p">:</span>
                    <span class="n">feature_position</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">indexes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">cur_feature_index</span> <span class="k">else</span> <span class="mi">1</span>

                    <span class="n">other_position</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">feature_position</span>
                    <span class="n">other_index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">[</span><span class="n">other_position</span><span class="p">]</span>
                    <span class="n">other_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>
                    <span class="n">other_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">other_index</span><span class="p">]</span>

                    <span class="c1"># Get the current additive scores and bin edges</span>
                    <span class="n">inter_additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

                    <span class="n">bin_starts_feature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">cur_feature_index</span>
                    <span class="p">)</span>
                    <span class="n">bin_starts_other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span>
                        <span class="n">other_index</span>
                    <span class="p">)</span>

                    <span class="c1"># Get the current interaction term score</span>
                    <span class="n">other_bin</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">other_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">):</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span>
                            <span class="n">bin_starts_other</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>
                        <span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">other_bin</span> <span class="o">=</span> <span class="n">bin_starts_other</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_example</span><span class="p">[</span><span class="n">other_index</span><span class="p">])</span>

                    <span class="n">feature_bin</span> <span class="o">=</span> <span class="n">bin_starts_feature</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cur_feature_value</span><span class="p">)</span>

                    <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">feature_bin</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">feature_inter_score</span> <span class="o">=</span> <span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">feature_bin</span><span class="p">]</span>

                    <span class="c1"># Extract the row or column where we fix the other feeature and</span>
                    <span class="c1"># vary the current feature</span>
                    <span class="n">feature_inter_bin_starts</span> <span class="o">=</span> <span class="n">bin_starts_feature</span>
                    <span class="n">feature_inter_additives</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">if</span> <span class="n">feature_position</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">)):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">other_bin</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                            <span class="n">feature_inter_additives</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inter_additives</span><span class="p">[</span><span class="n">other_bin</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

                    <span class="c1"># Register this interaction term</span>
                    <span class="n">associated_interactions</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                        <span class="s1">&#39;inter_index&#39;</span><span class="p">:</span> <span class="n">indexes</span><span class="p">,</span>
                        <span class="s1">&#39;cur_interaction_id&#39;</span><span class="p">:</span> <span class="n">cur_feature_id</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_score&#39;</span><span class="p">:</span> <span class="n">feature_inter_score</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">:</span> <span class="n">feature_inter_bin_starts</span><span class="p">,</span>
                        <span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">:</span> <span class="n">feature_inter_additives</span>
                    <span class="p">})</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">additives</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cur_feature_value</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">cur_cat_distance</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>

                <span class="c1"># Compute score gain which has two parts:</span>
                <span class="c1"># (1) gain from the change of main effect</span>
                <span class="c1"># (2) gain from the change of interaction effect</span>

                <span class="c1"># Main effect</span>
                <span class="n">main_score_gain</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># Interaction terms</span>
                <span class="n">inter_score_gain</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">associated_interactions</span><span class="p">:</span>
                    <span class="n">inter_bin_id</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_bin_starts&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                    <span class="n">inter_score_gain</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_additives&#39;</span><span class="p">][</span><span class="n">inter_bin_id</span><span class="p">]</span> <span class="o">-</span>\
                        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;feature_inter_score&#39;</span><span class="p">]</span>

                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">main_score_gain</span> <span class="o">+</span> <span class="n">inter_score_gain</span>

                <span class="c1"># Skip unhelpful options</span>
                <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">*</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Filter out of bound options</span>
                <span class="k">if</span> <span class="n">score_gain_bound</span> <span class="ow">and</span> <span class="n">skip_unhelpful</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&gt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">score_gain</span> <span class="o">&lt;</span> <span class="n">score_gain_bound</span><span class="p">:</span>
                        <span class="k">continue</span>

                <span class="n">cat_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span><span class="p">,</span> <span class="n">score_gain</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">inter_score_gain</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">cat_options</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generage all alternative options for this categorical variable. This function
would filter out all options that are not helpful for the counterfactual
generation.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cf_direction (int):</strong>  Integer <code>+1</code> if 0 =&gt; 1, <code>-1</code> if 1 =&gt; 0
(classification); <code>+1</code> if we need to incrase the prediction,
<code>-1</code> if decrease (regression).</li>
<li><strong>cur_feature_index (int):</strong>  The index of the current continuous feature.</li>
<li><strong>cur_feature_value (float):</strong>  The current feature value.</li>
<li><strong>cur_feature_score (float):</strong>  The score for the current feature value.</li>
<li><strong>cur_cat_distance (dict):</strong>  A map of feature_level =&gt; 1 - frequency.</li>
<li><strong>cur_example (list):</strong>  Current sample values.</li>
<li><strong>score_gain_bound (float):</strong>  Bound of the score gain. We do not collect
options that give <code>score_gain</code> &gt; <code>score_gain_bound</code> (when
<code>cf_direction=1</code>), or <code>score_gain</code> &lt; <code>score_gain_bound</code> (when
<code>cf_direction=-1</code>)</li>
<li><strong>skip_unhelpful (bool):</strong>  True if to skip options from main
effects that give opposite score gain. It is rare that there is a
positive score gain from pair-interaction that outweigh negative
score gain from two main effects, and adjusting the distance penalty.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>list: List of option tuples (target, score_gain, distance, bin_index).</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.generate_inter_options" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.generate_inter_options">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">generate_inter_options</span><span class="signature">(
    self,
    cur_feature_id,
    cur_feature_index_1,
    cur_feature_index_2,
    cur_feature_score,
    options
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">generate_inter_options</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_feature_id</span><span class="p">,</span> <span class="n">cur_feature_index_1</span><span class="p">,</span>
                               <span class="n">cur_feature_index_2</span><span class="p">,</span> <span class="n">cur_feature_score</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generage all possible options for this interaction variable.</span>

<span class="sd">        Interaction terms are interesting in this MILP. Each option counts as a</span>
<span class="sd">        variable, but each variable only affects the score gain, not the distance.</span>

<span class="sd">        Note that in EBM, the bin definitions for interaction terms can be different</span>
<span class="sd">        from their defintiions for individual continuous variables.</span>

<span class="sd">        To model interaction terms, we can think it as a binary variable. The</span>
<span class="sd">        value is determined by the multiplication of two main effect variables.</span>
<span class="sd">        Each interaction variable describes a combination of two main effect</span>
<span class="sd">        variables. Therefore, say continuous variable A has $x$ probable options,</span>
<span class="sd">        and another continuous variable B has $y$ probable options, then we should</span>
<span class="sd">        add $x \\times y$ binary variables to offset their probable interaction</span>
<span class="sd">        effects.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_feature_id (int): The id of this interaction effect.</span>
<span class="sd">            cur_feature_index_1 (int): The index of the first main effect.</span>
<span class="sd">            cur_feature_index_2 (int): The index of the second main effect.</span>
<span class="sd">            cur_feature_score (float): The score for the current feature value.</span>
<span class="sd">            options (dict): The current option list, feature_name -&gt;</span>
<span class="sd">                [`target`, `score_gain`, `distance`, `bin_id`].</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of option tuples (target, score_gain, distance, bin_index)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the sub-types for this interaction term</span>
        <span class="n">cur_feature_type_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_type_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># Get the sub-names for this interaction term</span>
        <span class="n">cur_feature_name_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_1</span><span class="p">]</span>
        <span class="n">cur_feature_name_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_feature_index_2</span><span class="p">]</span>

        <span class="c1"># The first column and row are reserved for missing values (even with</span>
        <span class="c1"># categorical features)</span>
        <span class="n">additives</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">cur_feature_id</span><span class="p">][</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="c1"># Four possibilities here: cont x cont, cont x cat, cat x cont, cat x cat.</span>
        <span class="c1"># Each has a different way to lookup the bin table.</span>
        <span class="n">inter_options</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate through all possible combinations of options from these two</span>
        <span class="c1"># variables</span>
        <span class="k">for</span> <span class="n">opt_1</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_1</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">opt_2</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">cur_feature_name_2</span><span class="p">]:</span>

                <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_1</span><span class="p">)</span>
                <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_feature_index_2</span><span class="p">)</span>

                <span class="n">bin_1</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">bin_2</span> <span class="o">=</span> <span class="kc">None</span>

                <span class="k">if</span> <span class="n">cur_feature_type_1</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cont x cont</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cont x cat</span>
                        <span class="n">bin_starts_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_1</span><span class="p">,</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">cur_feature_type_2</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                        <span class="c1"># cat x cont</span>
                        <span class="n">bin_starts_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">search_sorted_lower_index</span><span class="p">(</span><span class="n">bin_starts_2</span><span class="p">,</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># cat x cat</span>

                        <span class="c1"># locate the bin for each option value</span>
                        <span class="n">bin_1</span> <span class="o">=</span> <span class="n">bin_starts_1</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">bin_2</span> <span class="o">=</span> <span class="n">bin_starts_2</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                <span class="n">new_score</span> <span class="o">=</span> <span class="n">additives</span><span class="p">[</span><span class="n">bin_1</span><span class="p">,</span> <span class="n">bin_2</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">=</span> <span class="n">new_score</span> <span class="o">-</span> <span class="n">cur_feature_score</span>

                <span class="c1"># The score gain on the interaction term need to offset the interaction</span>
                <span class="c1"># score gain we have already counted on the main effect options. That</span>
                <span class="c1"># score is saved in the option tuple.</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
                <span class="n">score_gain</span> <span class="o">-=</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

                <span class="c1"># Optimization: here we cannot comapre the score_gain with</span>
                <span class="c1"># original interaction score to filter interaction options,</span>
                <span class="c1"># because the choice of two individual main effects do not</span>
                <span class="c1"># consier this interaction score</span>
                <span class="c1">#</span>
                <span class="c1"># Basically, the score gain of one interaction effect does</span>
                <span class="c1"># not affect the way we choose options for the main</span>
                <span class="c1"># variables. Only the solver can decide that :(</span>

                <span class="n">inter_options</span><span class="o">.</span><span class="n">append</span><span class="p">([</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                    <span class="n">score_gain</span><span class="p">,</span>
                    <span class="mi">0</span><span class="p">,</span>
                    <span class="p">[</span><span class="n">opt_1</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">opt_2</span><span class="p">[</span><span class="mi">3</span><span class="p">]],</span>
                    <span class="mi">0</span>
                <span class="p">])</span>

        <span class="k">return</span> <span class="n">inter_options</span>
</pre></div>

        </details>

            <div class="docstring"><p>Generage all possible options for this interaction variable.</p>

<p>Interaction terms are interesting in this MILP. Each option counts as a
variable, but each variable only affects the score gain, not the distance.</p>

<p>Note that in EBM, the bin definitions for interaction terms can be different
from their defintiions for individual continuous variables.</p>

<p>To model interaction terms, we can think it as a binary variable. The
value is determined by the multiplication of two main effect variables.
Each interaction variable describes a combination of two main effect
variables. Therefore, say continuous variable A has $x$ probable options,
and another continuous variable B has $y$ probable options, then we should
add $x \times y$ binary variables to offset their probable interaction
effects.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cur_feature_id (int):</strong>  The id of this interaction effect.</li>
<li><strong>cur_feature_index_1 (int):</strong>  The index of the first main effect.</li>
<li><strong>cur_feature_index_2 (int):</strong>  The index of the second main effect.</li>
<li><strong>cur_feature_score (float):</strong>  The score for the current feature value.</li>
<li><strong>options (dict):</strong>  The current option list, feature_name ->
[<code>target</code>, <code>score_gain</code>, <code>distance</code>, <code>bin_id</code>].</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>List of option tuples (target, score_gain, distance, bin_index)</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.create_milp" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.create_milp">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">create_milp</span><span class="signature">(
    cf_direction,
    needed_score_gain,
    features_to_vary,
    options,
    max_num_features_to_vary=None,
    muted_variables=[]
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">create_milp</span><span class="p">(</span><span class="n">cf_direction</span><span class="p">,</span> <span class="n">needed_score_gain</span><span class="p">,</span> <span class="n">features_to_vary</span><span class="p">,</span>
                    <span class="n">options</span><span class="p">,</span> <span class="n">max_num_features_to_vary</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">muted_variables</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a MILP to find counterfactuals (CF) using PuLP.</span>

<span class="sd">        Args:</span>
<span class="sd">            cf_direction (int): Integer +1 if 0 =&gt; 1, -1 if 1 =&gt; 0 (classification),</span>
<span class="sd">                +1 if we need to incrase the prediction, -1 if decrease (regression).</span>
<span class="sd">            needed_score_gain (float): The score gain needed to achieve the CF goal.</span>
<span class="sd">            features_to_vary (list[str]): Feature names of features that the</span>
<span class="sd">                generated CF can change.</span>
<span class="sd">            options (dict): Possible options for each variable. Each option is a</span>
<span class="sd">                list [target, score_gain, distance, bin_index].</span>
<span class="sd">            max_num_features_to_vary (int, optional): Max number of features that the</span>
<span class="sd">                generated CF can change. If the value is `None`, the CFs can</span>
<span class="sd">                change any number of features.</span>
<span class="sd">            muted_variables (list[str], optional): Variables that this MILP should</span>
<span class="sd">                not use. This is useful to mute optimal variables so we can explore</span>
<span class="sd">                diverse solutions. This list should not include interaction variables.</span>

<span class="sd">        Returns:</span>
<span class="sd">            A tuple (`model`, `variables`), where `model` is a pulp.LpProblem</span>
<span class="sd">            model that encodes the MILP problem, and `variables` is a dict of</span>
<span class="sd">            variables used in the `model`: `feature_name` =&gt; [`variables`].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Create a model (minimizing the distance)</span>
        <span class="n">model</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpProblem</span><span class="p">(</span><span class="s1">&#39;ebmCounterfactual&#39;</span><span class="p">,</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpMinimize</span><span class="p">)</span>

        <span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">score_gain</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">muted_variables_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">muted_variables</span><span class="p">)</span>

        <span class="c1"># Create variables</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>
            <span class="c1"># Each variable encodes an option (0: not use this option,</span>
            <span class="c1"># 1: use this option)</span>
            <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f</span><span class="p">]:</span>
                <span class="n">var_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

                <span class="c1"># Skip the muted variables</span>
                <span class="k">if</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">x</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span>
                                    <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                    <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                    <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Binary&#39;</span><span class="p">)</span>
                <span class="n">x</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">score_gain</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>
                <span class="n">distance</span> <span class="o">+=</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span>

                <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

            <span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

            <span class="c1"># A local constraint is that we can only at most selection one option from</span>
            <span class="c1"># one feature</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">cur_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span>

        <span class="c1"># Users can also set `max_num_features_to_vary` to control the total</span>
        <span class="c1"># number of features to vary</span>
        <span class="k">if</span> <span class="n">max_num_features_to_vary</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">main_variables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="n">main_variables</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">variables</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

            <span class="n">model</span> <span class="o">+=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">lpSum</span><span class="p">(</span><span class="n">main_variables</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_num_features_to_vary</span>

        <span class="c1"># Create variables for interaction effects</span>
        <span class="k">for</span> <span class="n">opt_name</span> <span class="ow">in</span> <span class="n">options</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">in</span> <span class="n">opt_name</span><span class="p">:</span>
                <span class="n">f1_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+)\sx\s.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>
                <span class="n">f2_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+\sx\s(.+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">opt_name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">f1_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span> <span class="ow">and</span> <span class="n">f2_name</span> <span class="ow">in</span> <span class="n">features_to_vary</span><span class="p">:</span>

                    <span class="c1"># We need to include this interaction effect</span>
                    <span class="n">cur_variables</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">pulp</span><span class="o">.</span><span class="n">LpVariable</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">,</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">opt_name</span><span class="p">,</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                              <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
                                            <span class="n">lowBound</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                            <span class="n">upBound</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                                            <span class="n">cat</span><span class="o">=</span><span class="s1">&#39;Continuous&#39;</span><span class="p">)</span>
                        <span class="n">z</span><span class="o">.</span><span class="n">setInitialValue</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># Need to iterate through existing variables for f1 and f2 to find</span>
                        <span class="c1"># the corresponding variables</span>
                        <span class="n">x_f1</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="n">x_f2</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="c1"># Skp if this interaction variable involves muted main variable</span>
                        <span class="n">x_f1_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f1_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">x_f2_name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">f2_name</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

                        <span class="k">if</span> <span class="n">x_f1_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span> <span class="ow">or</span> <span class="n">x_f2_name</span> <span class="ow">in</span> <span class="n">muted_variables_set</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f1_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f1_name</span><span class="p">:</span>
                                <span class="n">x_f1</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">[</span><span class="n">f2_name</span><span class="p">]:</span>
                            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">x_f2_name</span><span class="p">:</span>
                                <span class="n">x_f2</span> <span class="o">=</span> <span class="n">x</span>
                                <span class="k">break</span>

                        <span class="k">assert</span><span class="p">(</span><span class="n">x_f1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">x_f2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span>

                        <span class="c1"># variable z is actually the product of x_f1 and x_f2</span>
                        <span class="c1"># We can linearize it by 3 constraints</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f1</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&lt;=</span> <span class="n">x_f2</span>
                        <span class="n">model</span> <span class="o">+=</span> <span class="n">z</span> <span class="o">&gt;=</span> <span class="n">x_f1</span> <span class="o">+</span> <span class="n">x_f2</span> <span class="o">-</span> <span class="mi">1</span>

                        <span class="n">cur_variables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">z</span><span class="p">)</span>

                    <span class="n">variables</span><span class="p">[</span><span class="n">opt_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_variables</span>

        <span class="c1"># Use constraint to express counterfactual</span>
        <span class="k">if</span> <span class="n">cf_direction</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&gt;=</span> <span class="n">needed_score_gain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">model</span> <span class="o">+=</span> <span class="n">score_gain</span> <span class="o">&lt;=</span> <span class="n">needed_score_gain</span>

        <span class="c1"># We want to minimize the distance</span>
        <span class="n">model</span> <span class="o">+=</span> <span class="n">distance</span>

        <span class="k">return</span> <span class="n">model</span><span class="p">,</span> <span class="n">variables</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a MILP to find counterfactuals (CF) using PuLP.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cf_direction (int):</strong>  Integer +1 if 0 =&gt; 1, -1 if 1 =&gt; 0 (classification),
+1 if we need to incrase the prediction, -1 if decrease (regression).</li>
<li><strong>needed_score_gain (float):</strong>  The score gain needed to achieve the CF goal.</li>
<li><strong>features_to_vary (list[str]):</strong>  Feature names of features that the
generated CF can change.</li>
<li><strong>options (dict):</strong>  Possible options for each variable. Each option is a
list [target, score_gain, distance, bin_index].</li>
<li><strong>max_num_features_to_vary (int, optional):</strong>  Max number of features that the
generated CF can change. If the value is <code>None</code>, the CFs can
change any number of features.</li>
<li><strong>muted_variables (list[str], optional):</strong>  Variables that this MILP should
not use. This is useful to mute optimal variables so we can explore
diverse solutions. This list should not include interaction variables.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>A tuple (<code>model</code>, <code>variables</code>), where <code>model</code> is a pulp.LpProblem
  model that encodes the MILP problem, and <code>variables</code> is a dict of
  variables used in the <code>model</code>: <code>feature_name</code> =&gt; [<code>variables</code>].</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.print_solution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.print_solution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">print_solution</span><span class="signature">(self, cur_example, active_variables, options)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">print_solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cur_example</span><span class="p">,</span> <span class="n">active_variables</span><span class="p">,</span> <span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print the optimal solution.</span>

<span class="sd">        Args:</span>
<span class="sd">            cur_example (np.ndarray): the original data point.</span>
<span class="sd">            active_variables (list[variable]): binary variables with value 1.</span>
<span class="sd">            options (dict): all the possible options for all features.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">active_variables</span><span class="p">:</span>
            <span class="c1"># Skip interaction vars (included)</span>
            <span class="k">if</span> <span class="s1">&#39; x &#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">bin_i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="c1"># Find the original value</span>
                <span class="n">org_value</span> <span class="o">=</span> <span class="n">cur_example</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)]</span>

                <span class="c1"># Find the target bin</span>
                <span class="n">f_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
                <span class="n">f_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">f_index</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">f_type</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                    <span class="n">bin_starts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">f_index</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;[</span><span class="si">{}</span><span class="s1">,&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span><span class="p">])</span>

                    <span class="k">if</span> <span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">):</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bin_starts</span><span class="p">[</span><span class="n">bin_i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">target_bin</span> <span class="o">+=</span> <span class="s1">&#39; inf)&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">target_bin</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">org_value</span> <span class="o">=</span> <span class="s1">&#39;&quot;</span><span class="si">{}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">org_value</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_i</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Change &lt;</span><span class="si">{}</span><span class="s1">&gt; from </span><span class="si">{}</span><span class="s1"> to </span><span class="si">{}</span><span class="s1"> </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span><span class="p">,</span> <span class="n">org_value</span><span class="p">,</span> <span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">target_bin</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">option</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="p">))</span>
                        <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(.+):.+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
                <span class="n">f_name</span> <span class="o">=</span> <span class="n">f_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_x_&#39;</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="p">)</span>
                <span class="n">bin_0</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:(\d+),\d+&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>
                <span class="n">bin_1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;.+:\d+,(\d+)&#39;</span><span class="p">,</span> <span class="sa">r</span><span class="s1">&#39;\1&#39;</span><span class="p">,</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

                <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">options</span><span class="p">[</span><span class="n">f_name</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_0</span> <span class="ow">and</span> <span class="n">option</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">bin_1</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Trigger interaction term: &lt;</span><span class="si">{}</span><span class="s1">&gt;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">f_name</span>
                        <span class="p">))</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">* score gain: </span><span class="si">{:.4f}</span><span class="se">\n\t</span><span class="s1">* distance cost: </span><span class="si">{:.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">option</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span>
                        <span class="p">))</span>
                        <span class="k">break</span>
        <span class="nb">print</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print the optimal solution.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>cur_example (np.ndarray):</strong>  the original data point.</li>
<li><strong>active_variables (list[variable]):</strong>  binary variables with value 1.</li>
<li><strong>options (dict):</strong>  all the possible options for all features.</li>
</ul>
</div>


                            </div>
                            <div id="GAMCoach.compute_mad" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.compute_mad">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">compute_mad</span><span class="signature">(xs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_mad</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the median absolute deviation of a continuous feature.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of continuous values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: MAD value of xs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs_median</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">))</span>
        <span class="n">mad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">xs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span> <span class="o">-</span> <span class="n">xs_median</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mad</span>
</pre></div>

        </details>

            <div class="docstring"><p>Compute the median absolute deviation of a continuous feature.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>xs (np.ndarray):</strong>  A column of continuous values.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>float: MAD value of xs.</p>
</blockquote>
</div>


                            </div>
                            <div id="GAMCoach.compute_frequency_distance" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GAMCoach.compute_frequency_distance">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">compute_frequency_distance</span><span class="signature">(xs)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compute_frequency_distance</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For categorical variables, we compute 1 - frequency as their distance. It implies</span>
<span class="sd">        that switching to a frequent value takes less effort.</span>

<span class="sd">        Args:</span>
<span class="sd">            xs (np.ndarray): A column of categorical values.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: category level -&gt; 1 - frequency.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counter</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">counter</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">results</span>
</pre></div>

        </details>

            <div class="docstring"><p>For categorical variables, we compute 1 - frequency as their distance. It implies
that switching to a frequent value takes less effort.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>xs (np.ndarray):</strong>  A column of categorical values.</li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>dict: category level -> 1 - frequency.</p>
</blockquote>
</div>


                            </div>
                </section>
                <section id="search_sorted_lower_index">
                            <div class="attr function"><a class="headerlink" href="#search_sorted_lower_index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">search_sorted_lower_index</span><span class="signature">(sorted_edges, value)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">search_sorted_lower_index</span><span class="p">(</span><span class="n">sorted_edges</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary search to locate the correct bin for continuous features.&quot;&quot;&quot;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">right</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">left</span> <span class="o">+</span> <span class="nb">int</span><span class="p">((</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

    <span class="c1"># Handle out of bound issues</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">right</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">right</span>
    <span class="k">if</span> <span class="n">value</span> <span class="o">&lt;</span> <span class="n">sorted_edges</span><span class="p">[</span><span class="n">left</span><span class="p">]:</span>
        <span class="k">return</span> <span class="n">left</span>

    <span class="k">return</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span>
</pre></div>

        </details>

            <div class="docstring"><p>Binary search to locate the correct bin for continuous features.</p>
</div>


                </section>
                <section id="sigmoid">
                            <div class="attr function"><a class="headerlink" href="#sigmoid">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">sigmoid</span><span class="signature">(x)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Sigmoid function.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sigmoid function.</p>
</div>


                </section>
                <section id="get_model_data">
                            <div class="attr function"><a class="headerlink" href="#get_model_data">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_model_data</span><span class="signature">(
    ebm,
    x_train,
    model_info,
    resort_categorical=False,
    feature_info=None,
    feature_level_info=None,
    feature_config=None
)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">get_model_data</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="n">x_train</span><span class="p">,</span> <span class="n">model_info</span><span class="p">,</span> <span class="n">resort_categorical</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">feature_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">feature_level_info</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">feature_config</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the model data for GAM Coach.</span>
<span class="sd">    Args:</span>
<span class="sd">        ebm: Trained EBM model. ExplainableBoostingClassifier or</span>
<span class="sd">            ExplainableBoostingRegressor object.</span>
<span class="sd">        x_train: Training data. We use it to compute the mean absolute deviation</span>
<span class="sd">            score for continuous features, and frequency scores for categorical</span>
<span class="sd">            features.</span>
<span class="sd">        model_info: Information about the model (class names, regression target</span>
<span class="sd">            name). For classification, the order of classes matters. It should</span>
<span class="sd">            be consistent with the class encoding index. For example, the first</span>
<span class="sd">            element should be the name for class 0.</span>
<span class="sd">            It has format:</span>
<span class="sd">            `{&#39;classes&#39;: [&#39;loan rejection&#39;, &#39;loan approval&#39;]}` or</span>
<span class="sd">            `{&#39;regressionName&#39;: &#39;interest rate&#39;}`</span>
<span class="sd">        resort_categorical: Whether to sort the levels in categorical variable</span>
<span class="sd">            by increasing order if all levels can be converted to numbers.</span>
<span class="sd">        feature_info: You can provide a dictionary to give a separate display</span>
<span class="sd">            name and optional description for each feature. By default, the</span>
<span class="sd">            display name is the same as the feature name, and the description</span>
<span class="sd">            is an emtpy string. `feature_info` can be partial (only including</span>
<span class="sd">            some features). It has format:</span>
<span class="sd">            `{&#39;feature_name&#39;: [&#39;display_name&#39;, &#39;description&#39;]}`</span>
<span class="sd">        feature_level_info: You can provide a dictionary to give separate display</span>
<span class="sd">            name and optional description for each level of categorical features.</span>
<span class="sd">            By default, the display name is the same as the level name, and the</span>
<span class="sd">            description is an empty string. `feature_info` can be partial</span>
<span class="sd">            (e.g., only including some levels from some categorical features).</span>
<span class="sd">            It has format:</span>
<span class="sd">            `{&#39;feature_name&#39;: {level_id: [&#39;display_name&#39;, &#39;description&#39;]}}`</span>
<span class="sd">        feature_config: You can provide a dictionary to configure the difficulty,</span>
<span class="sd">            integer requirement, and acceptable range of individual features.</span>
<span class="sd">            The difficulty is an integer between 1 and 6: 1 (very easy to change),</span>
<span class="sd">            2 (easy), 3 (default), 4 (hard), 5 (very hard), 6 (impossible to change).</span>
<span class="sd">            By default, difficulty is set to 3 for all features, requiresInt is</span>
<span class="sd">            False for continuous variables, and acceptanceRange is None (search</span>
<span class="sd">            all range).</span>
<span class="sd">            The dictionary property has the following format:</span>
<span class="sd">            `{&#39;difficulty&#39;: 3, &#39;requiresInt&#39;: True, &#39;acceptableRange&#39;: None}`</span>
<span class="sd">    Returns:</span>
<span class="sd">        A Python dictionary of model data</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ROUND</span> <span class="o">=</span> <span class="mi">6</span>

    <span class="c1"># Main model info on each feature</span>
    <span class="n">features</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Track the encoding of categorical feature levels</span>
    <span class="n">labelEncoder</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Track the score range</span>
    <span class="n">score_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">))):</span>
        <span class="n">cur_feature</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;importance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_importances_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="c1"># Handle interaction term differently from cont/cat</span>
        <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;interaction&#39;</span><span class="p">:</span>
            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)</span>

            <span class="c1"># Info for each individual feature</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="c1"># Skip the first item from both dimensions</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span>
                                            <span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)[</span><span class="mi">1</span><span class="p">:,</span> <span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="c1"># Get the bin label info</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Encode categorical levels as integers</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span>
                    <span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel1&#39;</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span>
                    <span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel2&#39;</span><span class="p">]))</span>

            <span class="c1"># Get density info</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type1&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]))</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type2&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">pair_preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]))</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Skip the first item (reserved for missing value)</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ROUND</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cur_id</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">feature_groups_</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">col_bin_counts_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">1</span><span class="p">:]</span>

            <span class="c1"># Track the global score range</span>
            <span class="n">score_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">score_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">score_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">score_range</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                 <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">additive_terms_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">ebm</span><span class="o">.</span><span class="n">term_standard_deviations_</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="c1"># Add the binning information for continuous features</span>
            <span class="k">if</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">:</span>
                <span class="c1"># Add the bin information</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)</span>

                <span class="c1"># Use KDE to draw density plots for cont features</span>
                <span class="n">edges</span><span class="p">,</span> <span class="n">counts</span> <span class="o">=</span> <span class="n">_get_kde_sample</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">cur_id</span><span class="p">])</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">:</span>
                <span class="c1"># Get the level value mapping</span>
                <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">col_mapping_</span><span class="p">[</span><span class="n">cur_id</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">resort_categorical</span><span class="p">:</span>
                    <span class="n">level_str_to_int</span> <span class="o">=</span> <span class="n">_resort_categorical_level</span><span class="p">(</span>
                        <span class="n">level_str_to_int</span><span class="p">)</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                               <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_bin_labels</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)))</span>

                <span class="c1"># Add the hist information</span>
                <span class="c1"># For categorical data, the edges are strings</span>
                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">level_str_to_int</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
                                               <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_edges</span><span class="p">(</span><span class="n">cur_id</span><span class="p">)))</span>

                <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span>
                    <span class="n">ebm</span><span class="o">.</span><span class="n">preprocessor_</span><span class="o">.</span><span class="n">_get_hist_counts</span><span class="p">(</span><span class="n">cur_id</span><span class="p">),</span> <span class="n">ROUND</span>
                <span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">resort_categorical</span><span class="p">:</span>
                    <span class="n">cur_bin_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">],</span>
                        <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">],</span>
                    <span class="p">))</span>
                    <span class="n">cur_bin_info</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cur_bin_info</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;binLabel&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;additive&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;count&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_bin_info</span><span class="p">]</span>

                    <span class="n">cur_hist_info</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">zip</span><span class="p">(</span><span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">],</span> <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]))</span>
                    <span class="n">cur_hist_info</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cur_hist_info</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histEdge&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_hist_info</span><span class="p">]</span>
                    <span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;histCount&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">cur_hist_info</span><span class="p">]</span>

                <span class="c1"># Add the label encoding information</span>
                <span class="n">labelEncoder</span><span class="p">[</span><span class="n">cur_feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="n">i</span><span class="p">:</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">level_str_to_int</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">features</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cur_feature</span><span class="p">)</span>

    <span class="n">score_range</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ROUND</span><span class="p">),</span> <span class="n">score_range</span><span class="p">))</span>

    <span class="n">feature_names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">feature_types</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Sample data does not record interaction features</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;interaction&#39;</span><span class="p">):</span>
            <span class="n">feature_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">feature_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Compute the MAD scores and frequencies</span>
    <span class="n">ebm_cont_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;continuous&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">contMads</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cont_indexes</span><span class="p">:</span>
        <span class="n">contMads</span><span class="p">[</span><span class="n">ebm</span><span class="o">.</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">GAMCoach</span><span class="o">.</span><span class="n">compute_mad</span><span class="p">(</span><span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

    <span class="n">ebm_cat_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">feature_names</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">feature_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;categorical&#39;</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="n">catDistances</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ebm_cat_indexes</span><span class="p">:</span>
        <span class="n">catDistances</span><span class="p">[</span><span class="n">feature_names</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">GAMCoach</span><span class="o">.</span><span class="n">compute_frequency_distance</span><span class="p">(</span>
            <span class="n">x_train</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Initialize a feature description dictionary (provide more information about</span>
    <span class="c1"># each feature in the UI)</span>
    <span class="n">feature_descriptions</span> <span class="o">=</span> <span class="n">_init_feature_descriptions</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="n">labelEncoder</span><span class="p">)</span>

    <span class="c1"># Overwrite some entries in the default feature_descriptions</span>
    <span class="k">if</span> <span class="n">feature_info</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_info</span><span class="p">:</span>
            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;displayName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">feature_level_info</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_level_info</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">]:</span>
                <span class="n">display_name</span> <span class="o">=</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">level</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">description</span> <span class="o">=</span> <span class="n">feature_level_info</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">level</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;levelDescription&#39;</span><span class="p">][</span>
                    <span class="n">level</span><span class="p">][</span><span class="s1">&#39;displayName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">display_name</span>
                <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="s1">&#39;levelDescription&#39;</span><span class="p">][</span>
                    <span class="n">level</span><span class="p">][</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">description</span>

    <span class="c1"># Put descriptions under the &#39;features&#39; key</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">feature_descriptions</span><span class="p">):</span>
            <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_descriptions</span><span class="p">[</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>

    <span class="c1"># Set the feature configurations</span>
    <span class="n">feature_configurations</span> <span class="o">=</span> <span class="n">_init_feature_configuration</span><span class="p">(</span><span class="n">ebm</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">feature_config</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">feature_config</span><span class="p">:</span>
            <span class="n">cur_config</span> <span class="o">=</span> <span class="n">feature_config</span><span class="p">[</span><span class="n">feature</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="s1">&#39;requiresInt&#39;</span><span class="p">,</span> <span class="s1">&#39;difficulty&#39;</span><span class="p">,</span> <span class="s1">&#39;acceptableRange&#39;</span><span class="p">,</span>
                <span class="s1">&#39;requiresIncreasing&#39;</span><span class="p">,</span> <span class="s1">&#39;requiresDecreasing&#39;</span><span class="p">,</span> <span class="s1">&#39;usesTransform&#39;</span>
            <span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="ow">in</span> <span class="n">cur_config</span><span class="p">):</span>
                    <span class="n">feature_configurations</span><span class="p">[</span><span class="n">feature</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur_config</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="c1"># Attach the configuration to the feature field</span>
    <span class="k">for</span> <span class="n">feature</span> <span class="ow">in</span> <span class="n">features</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="n">feature_configurations</span><span class="p">):</span>
            <span class="n">feature</span><span class="p">[</span><span class="s1">&#39;config&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">feature_configurations</span><span class="p">[</span><span class="n">feature</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]]</span>

    <span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;intercept&#39;</span><span class="p">:</span> <span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="s1">&#39;classes_&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">ebm</span><span class="o">.</span><span class="n">intercept_</span><span class="p">,</span>
        <span class="s1">&#39;isClassifier&#39;</span><span class="p">:</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ebm</span><span class="p">,</span> <span class="s1">&#39;classes_&#39;</span><span class="p">),</span>
        <span class="s1">&#39;modelInfo&#39;</span><span class="p">:</span> <span class="n">model_info</span><span class="p">,</span>
        <span class="s1">&#39;features&#39;</span><span class="p">:</span> <span class="n">features</span><span class="p">,</span>
        <span class="s1">&#39;labelEncoder&#39;</span><span class="p">:</span> <span class="n">labelEncoder</span><span class="p">,</span>
        <span class="s1">&#39;scoreRange&#39;</span><span class="p">:</span> <span class="n">score_range</span><span class="p">,</span>
        <span class="s1">&#39;featureNames&#39;</span><span class="p">:</span> <span class="n">feature_names</span><span class="p">,</span>
        <span class="s1">&#39;featureTypes&#39;</span><span class="p">:</span> <span class="n">feature_types</span><span class="p">,</span>
        <span class="s1">&#39;contMads&#39;</span><span class="p">:</span> <span class="n">contMads</span><span class="p">,</span>
        <span class="s1">&#39;catDistances&#39;</span><span class="p">:</span> <span class="n">catDistances</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">data</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the model data for GAM Coach.</p>

<h6 id="args">Args</h6>

<ul>
<li><strong>ebm:</strong>  Trained EBM model. ExplainableBoostingClassifier or
ExplainableBoostingRegressor object.</li>
<li><strong>x_train:</strong>  Training data. We use it to compute the mean absolute deviation
score for continuous features, and frequency scores for categorical
features.</li>
<li><strong>model_info:</strong>  Information about the model (class names, regression target
name). For classification, the order of classes matters. It should
be consistent with the class encoding index. For example, the first
element should be the name for class 0.
It has format:
<code>{'classes': ['loan rejection', 'loan approval']}</code> or
<code>{'regressionName': 'interest rate'}</code></li>
<li><strong>resort_categorical:</strong>  Whether to sort the levels in categorical variable
by increasing order if all levels can be converted to numbers.</li>
<li><strong>feature_info:</strong>  You can provide a dictionary to give a separate display
name and optional description for each feature. By default, the
display name is the same as the feature name, and the description
is an emtpy string. <code>feature_info</code> can be partial (only including
some features). It has format:
<code>{'feature_name': ['display_name', 'description']}</code></li>
<li><strong>feature_level_info:</strong>  You can provide a dictionary to give separate display
name and optional description for each level of categorical features.
By default, the display name is the same as the level name, and the
description is an empty string. <code>feature_info</code> can be partial
(e.g., only including some levels from some categorical features).
It has format:
<code>{'feature_name': {level_id: ['display_name', 'description']}}</code></li>
<li><strong>feature_config:</strong>  You can provide a dictionary to configure the difficulty,
integer requirement, and acceptable range of individual features.
The difficulty is an integer between 1 and 6: 1 (very easy to change),
2 (easy), 3 (default), 4 (hard), 5 (very hard), 6 (impossible to change).
By default, difficulty is set to 3 for all features, requiresInt is
False for continuous variables, and acceptanceRange is None (search
all range).
The dictionary property has the following format:
<code>{'difficulty': 3, 'requiresInt': True, 'acceptableRange': None}</code></li>
</ul>

<h6 id="returns">Returns</h6>

<blockquote>
  <p>A Python dictionary of model data</p>
</blockquote>
</div>


                </section>
    </main>
<script>
    function escapeHTML(html) {
        return document.createElement('div').appendChild(document.createTextNode(html)).parentNode.innerHTML;
    }

    const originalContent = document.querySelector("main.pdoc");
    let currentContent = originalContent;

    function setContent(innerHTML) {
        let elem;
        if (innerHTML) {
            elem = document.createElement("main");
            elem.classList.add("pdoc");
            elem.innerHTML = innerHTML;
        } else {
            elem = originalContent;
        }
        if (currentContent !== elem) {
            currentContent.replaceWith(elem);
            currentContent = elem;
        }
    }

    function getSearchTerm() {
        return (new URL(window.location)).searchParams.get("search");
    }

    const searchBox = document.querySelector(".pdoc input[type=search]");
    searchBox.addEventListener("input", function () {
        let url = new URL(window.location);
        if (searchBox.value.trim()) {
            url.hash = "";
            url.searchParams.set("search", searchBox.value);
        } else {
            url.searchParams.delete("search");
        }
        history.replaceState("", "", url.toString());
        onInput();
    });
    window.addEventListener("popstate", onInput);


    let search, searchErr;

    async function initialize() {
        try {
            search = await new Promise((resolve, reject) => {
                const script = document.createElement("script");
                script.type = "text/javascript";
                script.async = true;
                script.onload = () => resolve(window.pdocSearch);
                script.onerror = (e) => reject(e);
                script.src = "../search.js";
                document.getElementsByTagName("head")[0].appendChild(script);
            });
        } catch (e) {
            console.error("Cannot fetch pdoc search index");
            searchErr = "Cannot fetch search index.";
        }
        onInput();

        document.querySelector("nav.pdoc").addEventListener("click", e => {
            if (e.target.hash) {
                searchBox.value = "";
                searchBox.dispatchEvent(new Event("input"));
            }
        });
    }

    function onInput() {
        setContent((() => {
            const term = getSearchTerm();
            if (!term) {
                return null
            }
            if (searchErr) {
                return `<h3>Error: ${searchErr}</h3>`
            }
            if (!search) {
                return "<h3>Searching...</h3>"
            }

            window.scrollTo({top: 0, left: 0, behavior: 'auto'});

            const results = search(term);

            let html;
            if (results.length === 0) {
                html = `No search results for '${escapeHTML(term)}'.`
            } else {
                html = `<h4>${results.length} search result${results.length > 1 ? "s" : ""} for '${escapeHTML(term)}'.</h4>`;
            }
            for (let result of results.slice(0, 10)) {
                let doc = result.doc;
                let url = `../${doc.modulename.replaceAll(".", "/")}.html`;
                if (doc.qualname) {
                    url += `#${doc.qualname}`;
                }

                let heading;
                switch (result.doc.type) {
                    case "function":
                        heading = `<span class="def">${doc.funcdef}</span> <span class="name">${doc.fullname}</span><span class="signature">(${doc.parameters.join(", ")})</span>`;
                        break;
                    case "class":
                        heading = `<span class="def">class</span> <span class="name">${doc.fullname}</span>`;
                        break;
                    default:
                        heading = `<span class="name">${doc.fullname}</span>`;
                        break;
                }
                html += `
                        <section class="search-result">
                        <a href="${url}" class="attr ${doc.type}">${heading}</a>
                        <div class="docstring">${doc.doc}</div>
                        </section>
                    `;

            }
            return html;
        })());
    }

    if (getSearchTerm()) {
        initialize();
        searchBox.value = getSearchTerm();
        onInput();
    } else {
        searchBox.addEventListener("focus", initialize, {once: true});
    }

    searchBox.addEventListener("keydown", e => {
        if (["ArrowDown", "ArrowUp", "Enter"].includes(e.key)) {
            let focused = currentContent.querySelector(".search-result.focused");
            if (!focused) {
                currentContent.querySelector(".search-result").classList.add("focused");
            } else if (
                e.key === "ArrowDown"
                && focused.nextElementSibling
                && focused.nextElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.nextElementSibling.classList.add("focused");
                focused.nextElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "ArrowUp"
                && focused.previousElementSibling
                && focused.previousElementSibling.classList.contains("search-result")
            ) {
                focused.classList.remove("focused");
                focused.previousElementSibling.classList.add("focused");
                focused.previousElementSibling.scrollIntoView({
                    behavior: "smooth",
                    block: "nearest",
                    inline: "nearest"
                });
            } else if (
                e.key === "Enter"
            ) {
                focused.querySelector("a").click();
            }
        }
    });
</script></body>
</html>